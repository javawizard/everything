

====================================================================
:mod:`ttftree` --- An implementation of functional 2-3 finger trees.
====================================================================

.. module:: ttftree
   :synopsis: An implementation of functional 2-3 finger trees.

This module provides an implementation of 2-3 finger trees for Python.

More documentation will be provided soon.

---------------------
Class CompoundMeasure
---------------------

A measure that combines the specified measures and produces a tuple of
their computed values. It can be used to annotate a tree with multiple
measures at the same time.

.. class:: CompoundMeasure(self, *measures, **kwargs)

   Creates a measure that combines the specified measures.

   One keyword argument, tuple_class, can be present. It specifies a
   subclass of tuple to use to combine the measures' computed values. This
   is primarily intended to allow named tuples (classes returned from
   collections.namedtuple) to be used instead of plain vanilla tuples.

   .. method:: convert(self, value)



   .. method:: operator(self, a_values, b_values)



-------------------
Class CustomMeasure
-------------------

A class for creating custom measures when one would rather just pass in the
convert, operator, and identity functions instead of creating a subclass of
Measure.

.. class:: CustomMeasure(self, convert, operator, identity)



   .. method:: convert(self, value)

      Converts a value stored in a tree to a value in the monoid on which
      this measure operates. This will be called for each value added to a
      tree using this measure, and only values returned from this function
      (as well as self.identity) will be passed to self.operator().

      The default implementation raises NotImplementedError.

   .. method:: operator(self, a, b)

      Take two values returned from self.convert() (or possibly
      self.identity) and combine them according to whatever logic this
      measure deems appropriate.

      This is the sum operator of the monoid under which this measure
      operates. As such, when passed self.identity as either of its
      arguments, it must return the other argument without any changes.

      The default implementation raises NotImplementedError.

----------
Class Deep
----------

A subclass of Tree representing trees containing two or more values.

Deep instances store two buffers (instances of Digit) representing their
first and last 1, 2, 3, or 4 values, and another Tree instance storing
groups (specifically Node instances) of all of the values in between.

Values added to a Deep instance with add_first and add_last are initially
stored in their respective Digit; when the digit becomes full, items are
popped off of it and turned into a Node, then pushed onto the nested tree.
This is where 2-3 finger trees get their amortized constant time complexity
for deque operations: because of the Digit buffers at either end and
because Nodes can contain only 2 or 3 items, a call to add_first or
add_last can descend into the nested tree at most every other call, and by
extension can only descend one more level every /fourth/ call, and so on.

Removal is accomplished the same way: if the Digit buffer on the side from
which an item is to be removed has only one item, a Node instance is popped
off of the nested tree and expanded into the Digit buffer. Thus the same
amortized constant time performance guarantees apply to without_first and
without_last as well.

.. class:: Deep(self, measure, left, spine, right)

   Creates a Deep instance using the specified measure (an instance of
   Measure), left buffer (an instance of Digit), spine (or nested tree; an
   instance of Tree whose values are Node instances), and right buffer
   (also an instance of Digit).

   .. method:: add_first(self, new_item)

      Returns a new Tree instance representing this tree with the specified
      item at the beginning.

      Time complexity: amortized O(1).

   .. method:: add_last(self, new_item)

      Returns a new Tree instance representing this tree with the specified
      item at the end.

      Time complexity: amortized O(1).

   .. method:: append(self, other)

      Concatenate the specified tree onto the end of this tree.

      Note that this tree and the other tree must use the same measure. If
      they don't, the resulting tree will pick one of their measures to use
      arbitrarily, which will likely cause pain and headaches if the two
      measures aren't designed to work with values produced by each other.

      Time complexity: amortized O(log min(m, n)), where m and n are the
      number of items stored in self and other, respectively. As a result,
      appending a tree of length 1 to another tree runs in amortized O(1)
      time.

   .. method:: get_first(self)

      Returns this tree's first value.

      Time complexity: O(1).

   .. method:: get_last(self)

      Returns this tree's last value.

      Time complexity: O(1).

   .. method:: partition(self, predicate)

      Convenience function that simply returns
      self.partition_with(predicate, self.measure.identity).

   .. method:: partition_with(self, predicate, initial_annotation)

      Partitions this tree around the specified monotonic predicate function.
      predicate is a function that takes a value in the monoid under which
      this tree's measure operates (i.e. a value returned from
      self.measure.convert(...)) and returns False or True.
      initial_annotation is a value to be combined (with
      self.measure.operator) with items before passing them to the predicate.

      The return value will be a tuple (left, right), where left is a tree
      containing the items just before the predicate transitioned from False
      to True and right is a tree containing the items after said transition.
      If the predicate returns False or True for every value it's passed,
      then right or left, respectively, will be empty.

      Note that the predicate need not necessarily be monotonic, but if it
      isn't, the particular False -> True transition on which the tree will
      be split is arbitrary. A monotonic predicate will give rise to exactly
      one such transition, so the location of the split will be
      deterministic.

      (For those unfamiliar with the term, a monotonic function is a function
      from one set of ordered values to another that maintains the relative
      order of the items given to it. In other words, the predicate function
      is monotonic if, when called on the monoidal value corresponding to
      every item in this tree, it returns False for the first m of them and
      then switches to returning True for the remaining n items.)

      See MeasureItemCount's docstring for an example of how to use this
      function.

      Time complexity: O(log min(m, n)), where m and n are the sizes of the
      resulting trees. As a result, splitting a tree with a predicate such
      that the left or right result tree has only one item (or zero items)
      runs in O(1) time. 

   .. method:: prepend(self, other)

      Returns a new tree representing the specified tree's items followed by
      this tree's items. This is just short for other.append(self).

   .. method:: without_first(self)

      Returns a new Tree instance representing this tree with its first item
      removed.

      Time complexity: amortized O(1).

   .. method:: without_last(self)

      Returns a new Tree instance representing this tree with its last item
      removed.

      Time complexity: amortized O(1).

-----------
Class Digit
-----------



.. class:: Digit(self, measure, *values)



   .. method:: count(self, value)

      S.count(value) -> integer -- return number of occurrences of value

   .. method:: index(self, value)

      S.index(value) -> integer -- return first index of value.
      Raises ValueError if the value is not present.

   .. method:: partition_digit(self, initial_annotation, predicate)

      partition_digit(function) => ((...), (...))

      Note that the two return values are tuples, not Digits, as they may
      need to be empty.

-----------
Class Empty
-----------

A subclass of Tree representing the empty tree.

.. class:: Empty(self, measure)



   .. method:: add_first(self, item)



   .. method:: add_last(self, item)



   .. method:: append(self, other)



   .. method:: get_first(self)



   .. method:: get_last(self)



   .. method:: iterate_values(self)



   .. method:: partition(self, predicate)

      Convenience function that simply returns
      self.partition_with(predicate, self.measure.identity).

   .. method:: partition_with(self, predicate, initial_annotation)



   .. method:: prepend(self, other)



   .. method:: without_first(self)



   .. method:: without_last(self)



--------------
Class Identity
--------------



.. class:: Identity

   x.__init__(...) initializes x; see help(type(x)) for signature

-------------
Class Measure
-------------

An object used to compute a tree's annotation.

Measures consist of a function capable of converting values in a tree to
values in a particular monoid (the convert attribute of Measure objects)
and the monoid's binary operation (the operator attribute) and identity
element (the identity attribute). The value of any given tree is the
monoidal sum of the values produced by the conversion function for all
values contained within the tree.

.. class:: Measure

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. method:: convert(self, value)

      Converts a value stored in a tree to a value in the monoid on which
      this measure operates. This will be called for each value added to a
      tree using this measure, and only values returned from this function
      (as well as self.identity) will be passed to self.operator().

      The default implementation raises NotImplementedError.

   .. method:: operator(self, a, b)

      Take two values returned from self.convert() (or possibly
      self.identity) and combine them according to whatever logic this
      measure deems appropriate.

      This is the sum operator of the monoid under which this measure
      operates. As such, when passed self.identity as either of its
      arguments, it must return the other argument without any changes.

      The default implementation raises NotImplementedError.

----------------------
Class MeasureItemCount
----------------------

A measure that measures the number of items contained within a given tree.

Trees annotated with such a measure can be asked for the number of items
that they contain in O(1) time by simply referencing the tree's annotation:

    tree_size = some_tree.annotation

They can also be asked to produce their nth item in O(log n) time:

    left, right = some_tree.partition(lambda v: v > n)
    nth_value = right.get_first()

A value can be inserted just before their nth item in O(log n) time:

    left, right = some_tree.partition(lambda v: v > n)
    some_tree = left.add_last(value_to_insert).append(right)

The value at the nth position in the tree can be removed in O(log n) time:

    left, right = some_tree.partition(lambda v: v > n)
    some_tree = left.append(right.without_first())

A subtree consisting of the mth (inclusive) through nth (exclusive) values
can be constructed in O(log n) time:

    mid, right = some_tree.partition(lambda v: v > n)
    left, mid = mid.partition(lambda v: v > m)
    subtree = mid

And finally, the mth (inclusive) through nth (exclusive) values can be
removed in O(log n) time:

    mid, right = some_tree.partition(lambda v: v > n)
    left, mid = mid.partition(lambda v: v > m)
    some_tree = left.append(right)

A singleton instance of this class is stored in ttftree.MEASURE_ITEM_COUNT.
You'll typically want to use that constant instead of constructing a whole
new instance of MeasureItemCount.

.. class:: MeasureItemCount(self)



   .. method:: convert(self, value)



   .. method:: operator(self, a, b)



---------------------
Class MeasureLastItem
---------------------

A measure that simply produces the second of the two items it's passed.

.. class:: MeasureLastItem(self)



   .. method:: convert(self, value)



   .. method:: operator(self, a, b)



   .. method:: semigroup_operator(self, a, b)



-------------------
Class MeasureMinMax
-------------------



.. class:: MeasureMinMax(self)



   .. method:: convert(self, value)



   .. method:: operator(self, a, b)



   .. method:: semigroup_operator(self, a, b)



-------------------------
Class MeasureWithIdentity
-------------------------

An abstract subclass of Measure that uses ttftree.IDENTITY as the identity
element and automatically handles checking for IDENTITY in its
implementation of operator(). It thus allows a semigroup (such as the set
of comparable objects under the min or max functions) to be used as a
monoid and therefore as a measure.

Subclasses must override convert and semigroup_operator. They must not
change self.identity or override operator.

.. class:: MeasureWithIdentity(self)



   .. method:: convert(self, value)

      Converts a value stored in a tree to a value in the monoid on which
      this measure operates. This will be called for each value added to a
      tree using this measure, and only values returned from this function
      (as well as self.identity) will be passed to self.operator().

      The default implementation raises NotImplementedError.

   .. method:: operator(self, a, b)



   .. method:: semigroup_operator(self, a, b)



----------
Class Node
----------



.. class:: Node(self, measure, *values)



   .. method:: count(self, value)

      S.count(value) -> integer -- return number of occurrences of value

   .. method:: index(self, value)

      S.index(value) -> integer -- return first index of value.
      Raises ValueError if the value is not present.

------------
Class Single
------------

A subclass of Tree representing trees containing a single value.

Instances of Single simply store a reference to the item passed to them.

.. class:: Single(self, measure, item)



   .. method:: add_first(self, new_item)



   .. method:: add_last(self, new_item)



   .. method:: append(self, other)



   .. method:: get_first(self)



   .. method:: get_last(self)



   .. method:: iterate_values(self)



   .. method:: partition(self, predicate)

      Convenience function that simply returns
      self.partition_with(predicate, self.measure.identity).

   .. method:: partition_with(self, predicate, initial_annotation)



   .. method:: prepend(self, other)



   .. method:: without_first(self)



   .. method:: without_last(self)



------------------
Class TTFTreeError
------------------



.. class:: TTFTreeError

   x.__init__(...) initializes x; see help(type(x)) for signature

----------------------
Class TranslateMeasure
----------------------

A measure that wraps another measure and behaves identically to it except
that it passes all values passed to self.convert() into the specified
function and passes the result into the wrapped measure's convert().

This can be used to, for example, create a wrapper around MeasureMinMax
that compares a certain attribute of its values instead of the values
themselves. For example, consider a tree with objects that have a
"priority" attribute. A measure suitable for using this tree as a priority
queue based on this attribute could be constructed thus:

measure = TranslateMeasure(lambda v: v.priority, MeasureMinMax())

.. class:: TranslateMeasure(self, function, measure)



   .. method:: convert(self, value)



   .. method:: operator(self, a, b)

      Take two values returned from self.convert() (or possibly
      self.identity) and combine them according to whatever logic this
      measure deems appropriate.

      This is the sum operator of the monoid under which this measure
      operates. As such, when passed self.identity as either of its
      arguments, it must return the other argument without any changes.

      The default implementation raises NotImplementedError.

----------
Class Tree
----------

A class representing a 2-3 finger tree.

Tree is an abstract class, so it can't itself be instantiated. Instead,
you'll want to construct an instance of Empty, one of the three subclasses
of Tree needed for the 2-3 finger tree algorithm (the other two are Single
and Deep), then add items to it as necessary.

A convenience function, to_tree, is provided to convert any Python sequence
into a Tree instance. 

.. class:: Tree

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. method:: partition(self, predicate)

      Convenience function that simply returns
      self.partition_with(predicate, self.measure.identity).

-----------------
Class TreeIsEmpty
-----------------

Exception raised from within Empty when things like get_first or
without_first are called on it.

.. class:: TreeIsEmpty

   x.__init__(...) initializes x; see help(type(x)) for signature

---------
Functions
---------



.. function:: deep_left(measure, maybe_left, spine, right)

   Same as Deep(measure, maybe_left, spine, right), except that maybe_left can
   be a list and is permitted to contain no items at all. In such a case, a
   node will be popped off of the spine and used as the left digit, with
   to_tree(right) being returned if the spine is actually empty.

.. function:: deep_right(measure, left, spine, maybe_right)

   Symmetrical operation to deep_left that allows its right digit to be a list
   that's potentially empty.

.. function:: to_tree(measure, sequence)

   Converts a given Python sequence (list, iterator, or anything else that
   can be the target of a for loop) into a Tree instance.

   This just creates an Empty instance and adds items to it with its add_last
   function, taking advantage of the fact that add_last runs in amortized
   O(1) time. The time complexity of to_tree is therefore O(n).

.. function:: value_iterator(tree)

   A generator function that yields each value from the given tree in
   succession.

   Each item is yielded in amortized O(1) time, so a full iteration requires
   O(n) time.

   The returned iterator only holds references to values that have yet to be
   produced; values earlier on in the tree will not be held on to, and as such
   can be garbage collected if nothing else holds references to them.