<p align="center"><font size="5">*XSM: An XML Programming Language*</font></p>

------

<font color="#0088ff" size="3"><b>To run XSM programs online using a Javascript interpreter I wrote, go [http://trivergia.com/xsm/interpreter.jsp here].</b></font>

=Description=
XSM is a programming language that uses XML to represent programs. It will be used as the embedded programming language inside !OpenGroove's help pages. The main reason is that the help pages need a small server-side scripting language (JSP is too heavyweight for this one, and I'm not inclined to jump through the hoops required to get it working in an embedded environment without TCP sockets being needed, and I implemented a Logo programming language interpreter in a single night so an XML programming language for which there are already syntax parsers can't be that difficult) that can be used to embed dynamic help content. This language needs to be independent of the help source (be it the opengroove wiki or files within a plugin), and should preferably be a language that will get ignored by Google Code's wiki parser. An XML-based programming language works nicely for this. It can be embedded within `<wiki:comment>` tags so that Google Code will ignore it, but !OpenGroove can know that xsm within a wiki comment should be run instead of ignored.

Then there could be some sort of pattern, maybe like `<wiki:comment><nohelp-start/></wiki:comment>` and then a corresponding nohelp-end pattern, that could appear, and the content between would show up on google code but !OpenGroove would ignore it. This would allow for warnings at the top of pages that indicate that the user is viewing this on the wiki, not !OpenGroove, so dynamic content might be missing.

------

<wiki:toc max_depth="3"/>

------

=The language=
The language is kind of a cross between Java, Javascript, and Logo (a variant of Lisp). I program in all three, so I've gotten ideas from them. The language shares javascript's and logo's dynamic typing (IE a variable does not have a type; its type is the type of whatever it's holding at the moment), and it shares java's and javascript's autolocal variables (IE you can't see a variable declared in a method that's calling yours). It does not support classes; it is therefore a procedural language. Functions are not first-class objects. Code can be run outside of a function. Code that returns that is run in a context where output is not expected has the output silently discarded.

All tags, except the literal tags, must contain only other XML tags, not plain text. For functions that accept some sort of text as an argument, the text should be wrapped with a string tag.

==Functions==
Functions are defined using the function tag. It has one attribute, name, which is the name of the function.

Functions are called by using the name of the function as a tag name. Tag attribute values are available within the function as variables named "param.NAME", where NAME is the name of the attribute. Each element within the function call's tag that returns a value is available as an "arg.N" variable, where N is the number starting at 1.

For example, the code:
{{{
<function name="test">
    <print><var name="param.somevalue"></print>
    <print><var name="arg.1"></print>
    <print><var name="arg.2"></print>
</function>
<test somevalue="an attribute">
    <string>a value</string>
    <number>12345</number>
</test>
}}}
Prints the following output:
{{{
an attribute
a value
12345
}}}

==Code/Argument/Literal functions==
First off, all custom-defined functions (those created by the user with the function tag) are always argument functions.

Code functions are those that are invoked with their tag content being XSM code. They then do something with it. Tags within a code function don't always have to return something for the code function to use. The function tag itself is a code function. Other examples include `if` and `while`. 

Argument functions are those that are invoked with their tag content being a list of values. These functions then do stuff with the values, not with the code. All tags within an argument function must return a value (but they are allowed to return null as their value). Functions _defined_ with the function tag are argument functions. Other examples include `set` and `var`.

Literal functions are those that take raw text as arguments. These might allow tags to be embedded within them, but they do their own special processing on the tags. Examples of literal functions include `string` and `number`.

==Variables==
Variables are dynamically-typed. XSM is a procedural language; there is no such thing as objects in XSM. Variables, therefore, hold one of these types of value:

|| *Literal tag name* || Description ||
|| boolean || A value that is either true or false. ||
|| number  || An signed, 64-bit integer. ||
|| double  || A signed, 64-bit decimal number. ||
|| string  || A piece of text. ||
|| list    || A list of other values. Lists themselves are passed around by reference, so passing a list to a function that modifies the list's content will result in the list being modified in the caller. The literal list tag is an argument function instead of a literal function, and makes a list of each value within it. ||
|| null    || Nothing. ||

Each of the literal tags can be used, with the tag's content being the value to use (which is specific to the type). Additionally, the tags true and false can be used directly in place of `<boolean>true</boolean>` and `<boolean>false</boolean>`, respectively. The string literal can have other tags embedded within it, amid text, and their return value will be embedded in the string.

To create a variable, you use the set tag. This can be invoked with the name attribute and one argument, or two arguments. In the latter case, the first argument is taken as the name of the variable.

To get a variable's value, you use the var tag. It takes either an attribute called name or a single argument, which is used as the name.

For example, the code:
{{{
<set name="foo">
    <string>Hello, how are you?</string>
</set>
<set>
    <string>bar</string>
    <string>I am fine</string>
</set>
<print>
    <var>
        <string>foo</string>
    </var>
</print>
<print>
    <var name="bar"/>
</print>
}}}
Prints the following output:
{{{
Hello, how are you?
I am fine
}}}

==Looping==
Looping is done with the while tag and the for tag. These are code functions that execute their content multiple times.

===While===
While takes an attribute called var. This should be the name of a variable that holds a boolean. The content of the while loop generally modifies this variable as it needs to. When the variable's value is false, the while loop stops looping.

The first child tag can be a condition tag, which contains the condition. In this case, var should not be present as an attribute.

For example, the code:
{{{
<set name="condition">
    <true/>
</set>
<set name="loop">
    <number>3</number>
</set>
<while var="condition">
    <print>
        <string>The number is <var name="loop"/></string>
    </print>
    <set name="loop">
        <add>
            <var name="loop"/>
            <number>1</number>
        </add>
    </set>
    <set name="condition">
        <less>
            <var name="loop"/>
            <number>7</number>
        </less>
    </set>
</while>
}}}
Prints the following output:
{{{
The number is 3
The number is 4
The number is 5
The number is 6
}}}

===For===
The for loop takes the attributes var, initial, final, and step. If any of these (except for var) need to be dynamic, there can be a tag named that whose value is the value to use. These must appear right at the top of the for loop.

=Built-in functions=
This is the list of functions that are built in to the XSM language. These do not include !OpenGroove-specific functions. The letter in parentheses immediately after the function name specifies what type of function it is: (a) means an argument function, (c) means a code function, and (l) means a literal function.

==Set (a)==
Sets the value of a variable, creating one if one does not already exist. The attribute name specifies the name of the variable to create. The first argument is the value that the variable should have. If the name attribute is not present, then the first argument is the name of the variable to create and the second is the value.

==Var (a)==
Returns the value of the specified variable. The variable is either contained in the attribute name, or it is the single argument to the var function.

==Print (a)==
Prints its single argument. If this program is a standalone program, this will be printed to the console. If this program is embedded inside a web page or an !OpenGroove help page, this will be sent to the page itself. If an attribute called newline has the value "false", then a newline will not be appended.

==Boolean (l)==
Returns a boolean that represents the literal value passed to it.

==True (a)==
Returns the boolean true.

==False (a)==
Returns the boolean false.

==Number (l)==
Returns a number that represents the literal number passed to it. The number is a 64-bit signed integer.

==Double (l)==
Returns a double that represents the literal number passed to it. The number is a 64-bit floating-point number.

==String (l)==
Returns a string representing its string content. Tags that return can be embedded, and the return value will be converted to a string form and included inside the string. Lists are represented as an open bracket and the value of each item in the list, separated by commas, followed by a close bracket.

==List (a)==
Creates a list that contains each argument to the function. The list command can be empty, which creates a list with no items in it.

==Null (a)==
Returns the value null.

==Function (c)==
Defines a new function. See [#Functions Functions] for more info.

==While (c)==

==For (c)==

==If (c)==

==Else (c)==

==Condition (a)==

==Add (a)==

==Subtract (a)==

==Multiply (a)==

==Divide (a)==

==Less (a)==

==Greater (a)==

==And (a)==

==Or (a)==

==Not (a)==

==Increment (a)==

==Decrement (a)==

==Size (a)==

==Copy (a)==

==Round (a)==

==Floor (a)==

==Ceiling (a)==

==Item (a)==

==Overwrite (a)==

==Resize (a)==

==Initial (a)==

==Final (a)==

==Step (a)==

==Return (a)==

=Examples=
{{{
<var name="testvar"><number>1</number></var>
}}}