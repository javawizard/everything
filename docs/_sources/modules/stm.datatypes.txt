

===============================================================================
:mod:`stm.datatypes` --- Some useful data types built on top of the STM system.
===============================================================================

.. module:: stm.datatypes
   :synopsis: Some useful data types built on top of the STM system.

This module provides several transactional data types built on top of the
primitives provided by the STM module.

-----------------------
Class BroadcastEndpoint
-----------------------

A broadcast endpoint from which items can be read.

This class should not be directly instantiated; instead, a BroadcastQueue
instance's new_endpoint() method should be called to obtain an endpoint
that reads from the queue in question.

.. class:: BroadcastEndpoint(self, var)



   .. method:: duplicate(self)

      Creates and returns a new endpoint containing exactly the same items as
      this endpoint. Items inserted into the BroadcastQueue from which this
      endpoint was created will be available on both this and the newly
      created endpoint.

   .. method:: get(self, block=True, timeout=None)

      Removes and returns the next available item from this endpoint.

      If block is False and there aren't any items currently available on
      this endpoint, Empty will be raised. If block is True, this function
      retries. If timeout is specified and there still aren't any items
      available on this endpoint after that many seconds, Timeout will be
      raised.

   .. attribute:: is_empty

      True if this endpoint has no items available (i.e. a call to get()
      would retry), False otherwise.

   .. method:: peek(self, block=False, timeout=None)

      Returns the next available item from this endpoint without removing it.

      The block and timeout parameters have the same effect as they do when
      passed to self.get(), but block defaults to False (which seems to be
      the more common use case when calling peek()).

   .. method:: replace(self, value)

      Pushes the specified value back onto this endpoint, such that the next
      call to get() will return the specified value.

      This is used internally to implement peek() and is_empty: an item is
      retrieved from the endpoint and then immediately pushed back onto the
      endpoint with replace(), thus leaving the endpoint unmodified. It can
      also be used externally as needed.

      This can be called multiple times to push multiple items onto an
      endpoint in LIFO order.

--------------------
Class BroadcastQueue
--------------------

A single-producer, multiple-consumer queue that can have multiple endpoints
from which items can be consumed.

Endpoints are created by calling new_endpoint(). Each endpoint initially
starts out empty; items become available as soon as the creating queue's
put() function is called.

Items inserted into the queue with put() become available on all endpoints
to consume. This allows BroadcastQueues to be used to broadcast values to
several different consumers.

When an endpoint is no longer needed, it can be simply discarded. Endpoints
hold a reference to the queue they were created from, not the other way
around, so they will be immediately garbage collected and any items unread
by the endpoint but not by any other endpoint immediately reclaimed.

An interesting side effect of this is that adding items to a queue that has
never had any endpoints created from it, or one that has had all of its
endpoints discarded, silently discards the items added to it, and is thus
a no-op.

.. class:: BroadcastQueue(self)

   Creates a new, empty broadcast queue.

   .. method:: new_endpoint(self)

      Creates a new BroadcastEndpoint that receives values added to this
      queue. The endpoint initially starts out empty; items will appear on it
      as soon as put() is called next.

   .. method:: put(self, value)

      Inserts an item into this queue. The item will then become available on
      all endpoints created from it.

-----------
Class Empty
-----------

Exception thrown from BroadcastEndpoint.get() when block=False is passed
in and no items are currently available.

.. class:: Empty

   x.__init__(...) initializes x; see help(type(x)) for signature

----------
Class Full
----------



.. class:: Full

   x.__init__(...) initializes x; see help(type(x)) for signature

-----------
Class TDict
-----------

UPDATE: This now uses 2-3 finger trees. Update accordingly.

A transactional dictionary.

Internally, transactional dicts are maintained with a single TVar holding a
copy-on-write binary tree annotated with dict keys. Insertion (and
appending), removal, and lookup are therefore all O(log n) operations.
len() is O(1), as is iter(), iterkeys(), iteritems(), and itervalues().

One nice property of using a copy-on-write binary tree is iteration: the
iterator returned from iter(tdict) is a snapshot of the dict's keys at that
point in time. The dict can therefore be safely modified during iteration,
without affecting the keys produced by the iteration. The same is, of
course, true of iterkeys, iteritems, and itervalues.

All of TDict's functions must be called within an STM transaction, with the
exception of __str__/__repr__, which, for the sake of convenience,
wrap themselves in a call to stm.atomically() internally. 

.. class:: TDict(self, initial_values=None)



   .. method:: clear(self)

      D.clear() -> None.  Remove all items from D.

   .. method:: get(self, key, default=None)

      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

   .. method:: items(self)



   .. method:: iteritems(self)



   .. method:: iterkeys(self)



   .. method:: itervalues(self)



   .. method:: keys(self)



   .. method:: pop(self, key, default=<object object at 0x7fa882c51040>)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
      If key is not found, d is returned if given, otherwise KeyError is raised.

   .. method:: popitem(self)

      D.popitem() -> (k, v), remove and return some (key, value) pair
      as a 2-tuple; but raise KeyError if D is empty.

   .. method:: setdefault(self, key, default=None)

      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

   .. method:: update(*args, **kwds)

      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
      If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
      In either case, this is followed by: for k, v in F.items(): D[k] = v

   .. method:: values(self)



-----------
Class TList
-----------

A transactional list.

Internally, transactional lists are maintained with a single TVar holding a
reference to a copy-on-write functional 2-3 finger tree (see the
afn.ttftree module) using afn.ttftree.MEASURE_ITEM_COUNT as its measure.
They thus give rise to some rather good performance characteristics:

    +------------------+--------------------------------------------------+
    | Time complexity: | Operations that run using this time complexity:  |
    +==================+==================================================+
    | amortized O(1)   | Inserting, removing, or looking up an item at    |
    |                  | either end of the list, e.g.:                    |
    |                  |                                                  |
    |                  |  * self.append(some_value)                       |
    |                  |  * self.pop()                                    |
    |                  |  * self.insert(0, some_value)                    |
    |                  |  * some_value = list[0]                          |
    |                  |  * some_value = list[-1]                         |
    +------------------+--------------------------------------------------+
    | O(1)             | len(self)                                        |
    |                  |                                                  |
    |                  | iter(self) (but note that calling the returned   |
    |                  | iterator's next() method is amortized O(1))      |
    +------------------+--------------------------------------------------+
    | O(log n)         | Inserting, removing, or looking up an item by an |
    |                  | arbitrary index, e.g.:                           |
    |                  |                                                  |
    |                  |  * insert(n, some_value)                         |
    |                  |  * some_value = list[n]                          |
    |                  |  * list[n] = some_value                          |
    |                  |  * del list[n], etc.                             |
    +------------------+--------------------------------------------------+
    | O(log min(m, n)) | Concatenating two lists, e.g.:                   |
    | where m and n    |                                                  |
    | are the sizes of |  * list1 + list2                                 |
    | the two lists    |  * list1.extend(list2)                           |
    | involved         |                                                  |
    +------------------+--------------------------------------------------+
    | O(log r) where r | Slicing a list, e.g.:                            |
    | is the size of   |                                                  |
    | the returned     |  * list[m:n]                                     |
    | list             |                                                  |
    +------------------+--------------------------------------------------+

One nice property of using a copy-on-write tree is iteration: the iterator
returned from iter(tlist) is a snapshot of the list at that point in time.
The list can therefore be safely modified during iteration without
affecting the items produced by the iteration.

All of TList's functions must be called within an STM transaction, with the
exception of __str__/__repr__, which, for the sake of convenience,
wrap themselves in a call to stm.atomically() internally.

.. class:: TList(self, initial_values=[])



   .. method:: append(self, value)

      S.append(object) -- append object to the end of the sequence

   .. method:: count(self, value)

      S.count(value) -> integer -- return number of occurrences of value

   .. method:: extend(self, values)



   .. method:: index(self, value)

      S.index(value) -> integer -- return first index of value.
      Raises ValueError if the value is not present.

   .. method:: insert(self, index, value)



   .. method:: pop(self, index=-1)

      S.pop([index]) -> item -- remove and return item at index (default last).
      Raise IndexError if list is empty or index is out of range.

   .. method:: remove(self, value)

      S.remove(value) -- remove first occurrence of value.
      Raise ValueError if the value is not present.

   .. method:: reverse(self)

      S.reverse() -- reverse *IN PLACE*

---------------------
Class TMutableWeakRef
---------------------

(This class is experimental.)

A transactional mutable weak reference.

This class is a hybrid of stm.TWeakRef and stm.TVar: it holds a weak
reference to its value, but permits its value to be modified as desired.

A function to be called when the value referred to by this TMutableWeakRef
is garbage collected may be specified. This callback will only be called
when the TMutableWeakRef's current value is garbage collected; it will not
be called on garbage collection of any of its former values.

.. class:: TMutableWeakRef(self, value, callback=None)

   Create a TMutableWeakRef with the specified initial value.

   Note that, as Python does not permit weak references to None, an
   initial non-None value must be specified.

   .. method:: get(self)



   .. method:: set(self, value)



-------------
Class TObject
-------------

An abstract class that causes all of its subclass's attributes to be backed
by a TDict. This results in the subclass's attributes being transactional,
so that they can be modified during a transaction without having to
explicitly wrap all of them with TVars.

.. class:: TObject(self)



----------
Class TSet
----------

A transactional mutable set.

Right now, this actually just uses an underlying Python set which it copies
on every write, so it's woefully inefficient. I'll be changing it to use
the AVL trees that TList and TDict use soon, but I need to figure out how
to properly implement weak sets in terms of them first. (I could always
just have weak nodes pointing to dereferenced objects collected only during
iteration, but then the iterators can't be completely isolated from the set
itself, so that needs some thought.)

.. class:: TSet(self, initial_items=set([]), backing_type=<type 'set'>)



   .. method:: add(self, item)



   .. method:: clear(self)

      This is slow (creates N new iterators!) but effective.

   .. method:: discard(self, item)



   .. method:: isdisjoint(self, other)

      Return True if two sets have a null intersection.

   .. method:: pop(self)

      Return the popped value.  Raise KeyError if empty.

   .. method:: remove(self, value)

      Remove an element. If not a member, raise a KeyError.

--------------------
Class _BroadcastItem
--------------------

_BroadcastItem(value, next)

.. class:: _BroadcastItem

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. attribute:: next

      Alias for field number 1

   .. attribute:: value

      Alias for field number 0

---------------------
Class _DictAnnotation
---------------------

_DictAnnotation(index, key)

.. class:: _DictAnnotation

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. attribute:: index

      Alias for field number 0

   .. attribute:: key

      Alias for field number 1

----------------
Class _DictEntry
----------------

_DictEntry(key, value)

.. class:: _DictEntry

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. attribute:: key

      Alias for field number 0

   .. attribute:: value

      Alias for field number 1