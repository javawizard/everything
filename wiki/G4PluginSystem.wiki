The G4 plugin system and how it works.

=Dependency Management=
The G4 plugin system includes support for managing dependencies. In particular, it includes support for dependency versions. This means that the Foo plugin can depend on the Bar plugin version 1, and the Baz plugin can depend on the Bar plugin version 2. Both versions will be downloaded, and the class loader will handle making Bar 1 available to Foo and Bar 2 available to Baz.

Plugins might therefore be installed simply because another plugin depends on them, and not because the user wanted to install that plugin. That brings me to the concept of "automatic plugins". An automatic plugin is one that was installed because another depended on it.

So now we have plugins and versions. A plugin is basically information that a particular plugin is wanted, whatever version is available. A version is a particular version of a plugin. Versions are installed for two reasons: 1, they are installed as a plugin and they are the latest version of that plugin (or the user has selected that they want that version specifically), and 2, because another version of another plugin depends on this version. Versions are updated as needed to satisfy dependencies, and always to the latest possible version.

A version can depend on any number of other plugin versions. And not just a specific version; plugin versions can depend on a version range too, which can be open-ended. So a plugin can say that it depends on any version later than, say, version 3 of another plugin, and the other plugin will be automatically updated when a new version of it is out even if the original plugin doesn't have any updates available.

Versions are made up of dotted numbers. The scheme for these is plugin-specific. A version also specifies how stable it is, with one of "stable", "beta", "unstable", and "nightly". This is appended to the version number with a hyphen. For example, version 1.2.3-stable would be a plugin version that is stable, while 1.2.4-beta would be a version that is getting close to being stable but probably has some bugs. Verison numbers must not occur twice, even with separate stability specifiers. For example, 1.2.4-beta might turn to 1.3-stable once it becomes stable.

Version numbers must also be sequential.

A depended version can specify the minimum stability requirement for the depended version. It can also specify a version range. 

=Version manifest=
A plugin version has a manifest file associated with it. This describes the actual plugin and how it works. This is in the XML file format.

It has a root element called `<plugin>`. This contains the attributes id, name, description, and, if the plugin is to have any extension points, class. Id should be unique for that particular plugin throughout the entire OpenGroove system. Name is a human-readable name for the plugin, description is a description for the plugin, and class is the name of a class in the plugin that implements PluginSupervisor. This class will be responsible for most of the code for the actual plugin. TODO: how to link between classes instantiated as a result of being an extension to the supervisor? Maybe add spring's object-like approach in, or see how eclipse handles things.

Within `<plugin>`, there is an `<authors>` tag. Within this there currently is any number of `<author>` tags, which have the attributes name, email, url, and comments. In the future, the `<authors>` tag will also be able to hold `<vcard>` tags, which will contain a vcard representing an author.

Then, within a plugin, there is a `<dependencies>` tag. This contains any number of `<dependency>` tags. Each dependency tag contains an attribute called id, which is the id of the plugin. Within each dependency tag is a number of version tags, which have the attributes start, end, and stability. If only one of start and end is specified, then the dependency is open-ended. If stability is unspecified, it is assumed to be "stable".

Anyway, back to the `<plugin>` tag. There is a `<points>` tag. Within that there is a `<point>` tag for each extension point. It contains an attribute called id, which is the id of the point.