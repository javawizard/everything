

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>parcon — parcon.py &mdash; Test Project  documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Test Project  documentation" href="../index.html" />
    <link rel="next" title="stm — A pure-Python software transactional memory system." href="stm.html" />
    <link rel="prev" title="fileutils — An object-oriented file access library for Python." href="fileutils.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="stm.html" title="stm — A pure-Python software transactional memory system."
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fileutils.html" title="fileutils — An object-oriented file access library for Python."
             accesskey="P">previous</a> |</li>
        <li><a href="../contents.html">Test Project  documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-parcon">
<span id="parcon-parcon-py"></span><h1><a class="reference internal" href="#module-parcon" title="parcon: parcon.py"><tt class="xref py py-mod docutils literal"><span class="pre">parcon</span></tt></a> &#8212; parcon.py<a class="headerlink" href="#module-parcon" title="Permalink to this headline">¶</a></h1>
<p>Parcon is a parser library written by Alexander Boyd and James Stoker. It&#8217;s
designed to be fast, easy to use, and to provide informative error messages.</p>
<p>(and it&#8217;s designed to include new, awesome things, like syntax diagram
generators.)</p>
<p>Technically, it&#8217;s a monadic parser combinator library, but you don&#8217;t need to
know that unless you&#8217;re doing really fancy things. (The bind and return
operations are provided by the Bind and Return parsers, respectively.) It&#8217;s
also technically a parser combinator library, but again, you usually won&#8217;t need
to know that.</p>
<p>Parcon grammars are written as Python statements that make use of various
classes provided with Parcon.</p>
<p>Parcon also supports generation of graphs and generation of syntax diagrams
(also known as railroad diagrams) from parsers. See the parcon.graph and
parcon.railroad modules, respectively, for information on how to generate these
graphs and diagrams.</p>
<p>To get started with Parcon, look at all of the subclasses of Parser, _GParser,
_RParser, and _GRParser, and specifically, their parse_string methods. And
perhaps take a look at this example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">SignificantLiteral</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">SignificantLiteral</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;(abbaabaab)&quot;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;(a)&quot;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">ParseException: Parse failure: At position 0</span>: <span class="n">expected one of &quot;(&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;(a&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">ParseException: Parse failure: At position 2</span>: <span class="n">expected one of &quot;a&quot;, &quot;b&quot;, &quot;)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;(ababacababa)&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">ParseException: Parse failure: At position 6</span>: <span class="n">expected one of &quot;a&quot;, &quot;b&quot;, &quot;)&quot;</span>
</pre></div>
</div>
<p>The Parser class, and hence all of its subclasses, overload a few operators
that can be used to make writing parsers easier. Here&#8217;s what each operator
ends up translating to:</p>
<blockquote>
<div><ul class="simple">
<li>x + y is the same as Then(x, y).</li>
<li>x | y is the same as First(x, y).</li>
<li>x - y is the same as Except(x, y).</li>
<li>x &amp; y is the same as And(x, y).</li>
<li>-x is the same as Optional(x).</li>
<li>+x is the same as OneOrMore(x).</li>
<li>~x is the same as Discard(x).</li>
<li>x[min:max] is the same as Repeat(x, min, max).</li>
<li>x[some_int] is the same as Repeat(x, some_int, some_int).</li>
<li>x[some_string] is the same as Tag(some_string, x).</li>
<li>x[...] (three literal dots) is the same as ZeroOrMore(x).</li>
<li>x[function] is the same as Translate(x, function).</li>
<li>x(name=&#8221;test&#8221;) is the same as Name(&#8220;test&#8221;, x).</li>
<li>x(desc=&#8221;test&#8221;) or x(description=&#8221;test&#8221;) is the same as Desc(&#8220;test&#8221;, x)</li>
<li>&#8220;x&#8221; op some_parser or some_parser op &#8220;x&#8221; is the same as Literal(&#8220;x&#8221;) op
some_parser or some_parser op Literal(&#8220;x&#8221;), respectively.</li>
</ul>
</div></blockquote>
<p>A simple expression evaluator written using Parcon:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">parcon</span> <span class="kn">import</span> <span class="n">number</span><span class="p">,</span> <span class="n">Forward</span><span class="p">,</span> <span class="n">InfixExpr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">operator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">term</span> <span class="o">=</span> <span class="n">number</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="n">expr</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">term</span> <span class="o">=</span> <span class="n">InfixExpr</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">term</span> <span class="o">=</span> <span class="n">InfixExpr</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">&lt;&lt;</span> <span class="n">term</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;expr&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Some example expressions that can now be evaluated using the above
simple expression evaluator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;1+2&quot;</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;1+2+3&quot;</span><span class="p">)</span>
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;1+2+3+4&quot;</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;3*4&quot;</span><span class="p">)</span>
<span class="go">12.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;5+3*4&quot;</span><span class="p">)</span>
<span class="go">17.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;(5+3)*4&quot;</span><span class="p">)</span>
<span class="go">32.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;10/4&quot;</span><span class="p">)</span>
<span class="go">2.5</span>
</pre></div>
</div>
<p>A syntax diagram can also be generated for the expression parser with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">draw_productions_to_png</span><span class="p">({},</span> <span class="s">&quot;expr-syntax.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Another example use of Parcon, this one being a JSON parser (essentially
a reimplementation of Python&#8217;s json.loads, without all of the fancy
arguments that it supports, and currently without support for backslash
escapes in JSON string literals):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">parcon</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">operator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cat_dicts</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">number</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="n">Digit</span><span class="p">()</span> <span class="o">+</span> <span class="o">-</span><span class="p">(</span><span class="n">SignificantLiteral</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="o">+</span><span class="n">Digit</span><span class="p">()))[</span><span class="n">flatten</span><span class="p">][</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">][</span><span class="nb">float</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boolean</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="s">&quot;true&quot;</span><span class="p">)[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">True</span><span class="p">]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">(</span><span class="s">&quot;false&quot;</span><span class="p">)[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">False</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">string</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">Exact</span><span class="p">(</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">AnyChar</span><span class="p">()</span> <span class="o">-</span> <span class="n">CharIn</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\&quot;</span><span class="s">&#39;</span><span class="p">)))</span> <span class="o">+</span>  <span class="s">&#39;&quot;&#39;</span><span class="p">)[</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">null</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="s">&quot;null&quot;</span><span class="p">)[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">None</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">json</span><span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,)])[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_object</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;{&quot;</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">InfixExpr</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">cat_dicts</span><span class="p">)]),</span> <span class="p">{})</span> <span class="o">+</span> <span class="s">&quot;}&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_list</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;[&quot;</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">InfixExpr</span><span class="p">(</span><span class="n">json</span><span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">]],</span> <span class="p">[(</span><span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">)]),</span> <span class="p">[])</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">json_object</span> <span class="o">|</span> <span class="n">json_list</span> <span class="o">|</span> <span class="n">string</span> <span class="o">|</span> <span class="n">boolean</span> <span class="o">|</span> <span class="n">null</span> <span class="o">|</span> <span class="n">number</span><span class="p">)</span>
</pre></div>
</div>
<p>Thereafter, json.parse_string(text) can be used as a replacement for
Python&#8217;s json.loads.</p>
<p>An interesting fact: the set of all Parcon parsers form a monoid with the
binary operation being the Then parser (or the + operator, since it produces a
Then parser) and the identity element being Return(None).</p>
<div class="section" id="class-alpha">
<h2>Class Alpha<a class="headerlink" href="#class-alpha" title="Permalink to this headline">¶</a></h2>
<p>Same as CharIn(upper_chars + lower_chars).</p>
<dl class="class">
<dt id="parcon.Alpha">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Alpha</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Alpha" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Alpha.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Alpha.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alpha.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Alpha.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alpha.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Alpha.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alpha.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Alpha.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alpha.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Alpha.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alpha.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Alpha.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alpha.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Alpha.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Alpha.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Alpha.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alpha.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Alpha.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Alpha.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Alpha.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alpha.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Alpha.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-alphanum">
<h2>Class Alphanum<a class="headerlink" href="#class-alphanum" title="Permalink to this headline">¶</a></h2>
<p>Same as CharIn(upper_chars + lower_chars + digit_chars).</p>
<dl class="class">
<dt id="parcon.Alphanum">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Alphanum</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Alphanum" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Alphanum.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Alphanum.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alphanum.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Alphanum.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alphanum.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Alphanum.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alphanum.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Alphanum.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alphanum.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Alphanum.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alphanum.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Alphanum.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alphanum.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Alphanum.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Alphanum.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Alphanum.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alphanum.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Alphanum.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Alphanum.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Alphanum.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Alphanum.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Alphanum.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-and">
<h2>Class And<a class="headerlink" href="#class-and" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches whatever its specified parser matches as long as its
specified check_parser also matches at the same location. This could be
considered the opposite of Except: And matches when the second parser it&#8217;s
passed also matches, while Except matches when the second parser it&#8217;s
passed does not match. Wrapping the second parser with Not can make And
behave as Except and vice versa, although using whichever one makes more
sense will likely lead to more informative error messages when parsing
fails.</p>
<dl class="class">
<dt id="parcon.And">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">And</tt><big>(</big><em>self</em>, <em>parser</em>, <em>check_parser</em><big>)</big><a class="headerlink" href="#parcon.And" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.And.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.And.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.And.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.And.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.And.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.And.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.And.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.And.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.And.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.And.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.And.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.And.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.And.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.And.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.And.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.And.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.And.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.And.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.And.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.And.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.And.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.And.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-anycase">
<h2>Class AnyCase<a class="headerlink" href="#class-anycase" title="Permalink to this headline">¶</a></h2>
<p>A case-insensitive version of Literal. Behaves exactly the same as Literal
does, but without regard to the case of the input.</p>
<p>If enough people request a version that returns the matched text instead of
None (send me an email if you&#8217;re one of these people; my email is at the
top of this file, in the module docstring), I&#8217;ll provide such a parser. For
now, though, you can use a Regex parser to accomplish the same thing.</p>
<dl class="class">
<dt id="parcon.AnyCase">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">AnyCase</tt><big>(</big><em>self</em>, <em>text</em><big>)</big><a class="headerlink" href="#parcon.AnyCase" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.AnyCase.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.AnyCase.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyCase.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.AnyCase.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyCase.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.AnyCase.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyCase.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.AnyCase.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyCase.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.AnyCase.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyCase.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.AnyCase.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyCase.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.AnyCase.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.AnyCase.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.AnyCase.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyCase.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.AnyCase.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.AnyCase.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.AnyCase.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyCase.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.AnyCase.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-anychar">
<h2>Class AnyChar<a class="headerlink" href="#class-anychar" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches any single character. It returns the character that
it matched.</p>
<dl class="class">
<dt id="parcon.AnyChar">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">AnyChar</tt><a class="headerlink" href="#parcon.AnyChar" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="method">
<dt id="parcon.AnyChar.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.AnyChar.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyChar.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.AnyChar.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyChar.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.AnyChar.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyChar.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.AnyChar.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyChar.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.AnyChar.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyChar.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.AnyChar.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyChar.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.AnyChar.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.AnyChar.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.AnyChar.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyChar.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.AnyChar.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.AnyChar.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.AnyChar.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.AnyChar.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.AnyChar.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-bind">
<h2>Class Bind<a class="headerlink" href="#class-bind" title="Permalink to this headline">¶</a></h2>
<p>A parser that functions similar to Then, but that allows the second parser
to be determined from the value that the first parser produced. It&#8217;s
constructed as Bind(parser, function). parser is the first parser to run.
function is a function that accepts one argument, the value that the first
parser produced. It will be called whenever the first parser succeeds; the
value that the first parser produced will be passed in, and the function
should return a second parser. This parser will then be applied immediately
after where the first parser finished parsing from (similar to how Then
starts its second parser parsing after where its first parser finished).
Bind then returns the value that the second parser produced.</p>
<p>Those of you familiar with functional programming will notice that this
parser implements a monadic bind, hence its name.</p>
<dl class="class">
<dt id="parcon.Bind">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Bind</tt><big>(</big><em>self</em>, <em>parser</em>, <em>function</em><big>)</big><a class="headerlink" href="#parcon.Bind" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Bind.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Bind.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Bind.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Bind.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Bind.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Bind.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Bind.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>whitespace</em><big>)</big><a class="headerlink" href="#parcon.Bind.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Bind.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Bind.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-charin">
<h2>Class CharIn<a class="headerlink" href="#class-charin" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches a single character as long as it is in the specified
sequence (which can be a string or a list of one-character strings). It
returns the character matched.</p>
<dl class="class">
<dt id="parcon.CharIn">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">CharIn</tt><big>(</big><em>self</em>, <em>chars</em><big>)</big><a class="headerlink" href="#parcon.CharIn" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.CharIn.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.CharIn.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharIn.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.CharIn.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharIn.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.CharIn.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharIn.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.CharIn.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharIn.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.CharIn.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharIn.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.CharIn.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharIn.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.CharIn.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.CharIn.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.CharIn.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharIn.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.CharIn.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.CharIn.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.CharIn.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharIn.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.CharIn.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-charnotin">
<h2>Class CharNotIn<a class="headerlink" href="#class-charnotin" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches a single character as long as it is not in the
specified sequence. This is much the opposite of CharIn.</p>
<dl class="class">
<dt id="parcon.CharNotIn">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">CharNotIn</tt><big>(</big><em>self</em>, <em>chars</em><big>)</big><a class="headerlink" href="#parcon.CharNotIn" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.CharNotIn.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.CharNotIn.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharNotIn.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.CharNotIn.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharNotIn.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.CharNotIn.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.CharNotIn.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.CharNotIn.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.CharNotIn.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.CharNotIn.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-chars">
<h2>Class Chars<a class="headerlink" href="#class-chars" title="Permalink to this headline">¶</a></h2>
<p>A parser that parses a specific number of characters and returns them as
a string. Chars(5), for example, would parse exactly five characters in a
row, and return a string of length 5. This would be essentially identical
to AnyChar()[5:5][&#8220;&#8221;.join], except for two things: 1, the whitespace parser
is not applied in between each character parsed by Chars (although it is
applied just before the first character), and 2, Chars is much more
efficient than the aforementioned expression using AnyChar.</p>
<p>This can be used in combination with Bind to create a parser that parses
a binary protocol where a fixed number of bytes are present that specify
the length of the rest of a particular packet, followed by the rest of the
packet itself. For example, imagine a protocol where packets look like this:</p>
<p>length b1 b2 b3 ... blength</p>
<p>a.k.a. a byte indicating the length of the data carried in that packet,
followed by the actual data of the packet. Such a packet could be parsed
into a string containing the data of a single packet with this:</p>
<p>Bind(AnyChar(), lambda x: Chars(ord(x)))</p>
<dl class="class">
<dt id="parcon.Chars">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Chars</tt><big>(</big><em>self</em>, <em>number</em><big>)</big><a class="headerlink" href="#parcon.Chars" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Chars.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Chars.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Chars.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Chars.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Chars.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Chars.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Chars.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Chars.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Chars.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Chars.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-description">
<h2>Class Description<a class="headerlink" href="#class-description" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="parcon.Description">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Description</tt><big>(</big><em>self</em>, <em>description</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.Description" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Description.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Description.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Description.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Description.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Description.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Description.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Description.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Description.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Description.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Description.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Description.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Description.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Description.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Description.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Description.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Description.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Description.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Description.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Description.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Description.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Description.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Description.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-digit">
<h2>Class Digit<a class="headerlink" href="#class-digit" title="Permalink to this headline">¶</a></h2>
<p>Same as CharIn(digit_chars).</p>
<dl class="class">
<dt id="parcon.Digit">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Digit</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Digit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Digit.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Digit.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Digit.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Digit.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Digit.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Digit.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Digit.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Digit.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Digit.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Digit.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Digit.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Digit.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Digit.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Digit.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Digit.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Digit.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Digit.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Digit.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Digit.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Digit.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Digit.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Digit.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-discard">
<h2>Class Discard<a class="headerlink" href="#class-discard" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches if the parser it&#8217;s constructed with matches. It
consumes the same amount of input that the specified parser does, but this
parser always returns None as the result. Since instances of Then treat
None values specially, you&#8217;ll likely use this parser in conjunction with
Then in some grammars.</p>
<dl class="class">
<dt id="parcon.Discard">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Discard</tt><big>(</big><em>self</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.Discard" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Discard.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Discard.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Discard.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Discard.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Discard.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Discard.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Discard.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Discard.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Discard.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Discard.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Discard.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Discard.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Discard.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Discard.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Discard.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Discard.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Discard.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Discard.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Discard.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Discard.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Discard.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Discard.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-eanychar">
<h2>Class EAnyChar<a class="headerlink" href="#class-eanychar" title="Permalink to this headline">¶</a></h2>
<p>An expectation indicating that any character was expected.</p>
<dl class="class">
<dt id="parcon.EAnyChar">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">EAnyChar</tt><a class="headerlink" href="#parcon.EAnyChar" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="method">
<dt id="parcon.EAnyChar.format">
<tt class="descname">format</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.EAnyChar.format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="class-eanycharin">
<h2>Class EAnyCharIn<a class="headerlink" href="#class-eanycharin" title="Permalink to this headline">¶</a></h2>
<p>An expectation indicating that any character in a particular sequence of
characters (a list of one-character strings, or a string containing the
expected characters) was expected.</p>
<dl class="class">
<dt id="parcon.EAnyCharIn">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">EAnyCharIn</tt><big>(</big><em>self</em>, <em>chars</em><big>)</big><a class="headerlink" href="#parcon.EAnyCharIn" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.EAnyCharIn.format">
<tt class="descname">format</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.EAnyCharIn.format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="class-eanycharnotin">
<h2>Class EAnyCharNotIn<a class="headerlink" href="#class-eanycharnotin" title="Permalink to this headline">¶</a></h2>
<p>An expectation indicating that any character not in a particular sequence of
characters (a list of one-character strings, or a string containing the
expected characters) was expected.</p>
<dl class="class">
<dt id="parcon.EAnyCharNotIn">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">EAnyCharNotIn</tt><big>(</big><em>self</em>, <em>chars</em><big>)</big><a class="headerlink" href="#parcon.EAnyCharNotIn" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.EAnyCharNotIn.format">
<tt class="descname">format</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.EAnyCharNotIn.format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="class-ecustomexpectation">
<h2>Class ECustomExpectation<a class="headerlink" href="#class-ecustomexpectation" title="Permalink to this headline">¶</a></h2>
<p>An expectation indicating that some custom value was expected. This is used
when instances of the Expected parser fail. Users implementing their own
subclass of Parser that don&#8217;t want to write a corresponding subclass of
Expectation but that find that none of the current subclasses of
Expectation fit their needs might also want to use ECustomExpectation.</p>
<dl class="class">
<dt id="parcon.ECustomExpectation">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">ECustomExpectation</tt><big>(</big><em>self</em>, <em>message</em><big>)</big><a class="headerlink" href="#parcon.ECustomExpectation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.ECustomExpectation.format">
<tt class="descname">format</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.ECustomExpectation.format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="class-eregex">
<h2>Class ERegex<a class="headerlink" href="#class-eregex" title="Permalink to this headline">¶</a></h2>
<p>An expectation indicating that some regular expression was expected.</p>
<dl class="class">
<dt id="parcon.ERegex">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">ERegex</tt><big>(</big><em>self</em>, <em>pattern_text</em><big>)</big><a class="headerlink" href="#parcon.ERegex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.ERegex.format">
<tt class="descname">format</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.ERegex.format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="class-estringliteral">
<h2>Class EStringLiteral<a class="headerlink" href="#class-estringliteral" title="Permalink to this headline">¶</a></h2>
<p>An expectation indicating that some literal string was expected. When
formatted, the string will be enclosed in double quotes. In the future, I
may have the representation as returned from Python&#8217;s repr function be used
instead.</p>
<dl class="class">
<dt id="parcon.EStringLiteral">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">EStringLiteral</tt><big>(</big><em>self</em>, <em>text</em><big>)</big><a class="headerlink" href="#parcon.EStringLiteral" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.EStringLiteral.format">
<tt class="descname">format</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.EStringLiteral.format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="class-eunsatisfiable">
<h2>Class EUnsatisfiable<a class="headerlink" href="#class-eunsatisfiable" title="Permalink to this headline">¶</a></h2>
<p>An expectation indicating that there is no input that could have been
present that would have made the parser in question succeed or consume more
input. Invalid(), for example, returns EUnsatisfiable() since nothing will
make an Invalid match, and EStringLiteral, when it succeeds, returns
EUnsatisfiable() since there isn&#8217;t any additional text that could be added
that would make EStringLiteral consume more of the input.</p>
<p>EUnsatisfiable is treated specially by format_failure; instances of it are
removed if there are expectations of any other type in the list provided
to format_failure. If there are not, the EUnsatisfiable with the greatest
position (expectations are stored as tuples of (position, Expectation)) is
used, and the message will look something like &#8220;At position n: expected
EOF&#8221;.</p>
<dl class="class">
<dt id="parcon.EUnsatisfiable">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">EUnsatisfiable</tt><a class="headerlink" href="#parcon.EUnsatisfiable" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="method">
<dt id="parcon.EUnsatisfiable.format">
<tt class="descname">format</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.EUnsatisfiable.format" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="class-end">
<h2>Class End<a class="headerlink" href="#class-end" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches only at the end of input. It parses whitespace before
checking to see if it&#8217;s at the end, so it will still match even if there is
some whitespace at the end of the input. (If you don&#8217;t want it to consume
any whitespace, you can use Exact(End()).)</p>
<p>This parser&#8217;s result is always None. End(True) will consume any whitespace
that it matches while searching for the end, which can improve performance
under certain circumstances by avoiding having to parse out whitespace a
second time. End(False) will still skip over whitespace while searching
for the end, but it won&#8217;t consume it, which may be desirable if the
whitespace in question is significant to the grammar. End() is the same as
End(True).</p>
<p>Note that this parser succeeds at the end of the /logical/ input given to
it; specifically, if you&#8217;ve restricted the region to parse with Length, End
matches at the end of the limit set by Limit, not at the end of the actual
input. A more technical way to put it would be to say that if, after
removing whitespace, the resulting position is equal to the end parameter
passed to the parse function, then this parser matches. Otherwise, it fails.</p>
<dl class="class">
<dt id="parcon.End">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">End</tt><big>(</big><em>self</em>, <em>consume=True</em><big>)</big><a class="headerlink" href="#parcon.End" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new End parser. consume is described in the class docstring.</p>
<dl class="method">
<dt id="parcon.End.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.End.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.End.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.End.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.End.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.End.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.End.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.End.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.End.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.End.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-exact">
<h2>Class Exact<a class="headerlink" href="#class-exact" title="Permalink to this headline">¶</a></h2>
<p>A parser that returns whatever the specified parser returns, but Invalid()
will be passed as the whitespace parser to the specified parser when its
parse method is called. This allows for sections of the grammar to take
whitespace significantly, which is useful in, for example, string literals.
For example, the following parser, intended to parse string literals,
demonstrates the problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">stringLiteral</span> <span class="o">=</span> <span class="s">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">AnyChar</span><span class="p">()</span> <span class="o">-</span> <span class="s">&#39;&quot;&#39;</span><span class="p">)[</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;&quot;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stringLiteral</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&#39;&quot;Hello, great big round world&quot;&#39;</span><span class="p">)</span>
<span class="go">&#39;Hello,greatbigroundworld&#39;</span>
</pre></div>
</div>
<p>This is because the whitespace parser (which defaults to Whitespace())
consumed all of the space in the string literal. This can, however, be
rewritten using Exact to mitigate this problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">stringLiteral</span> <span class="o">=</span> <span class="n">Exact</span><span class="p">(</span><span class="s">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">AnyChar</span><span class="p">()</span> <span class="o">-</span> <span class="s">&#39;&quot;&#39;</span><span class="p">)[</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;&quot;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stringLiteral</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&#39;&quot;Hello, great big round world&quot;&#39;</span><span class="p">)</span>
<span class="go">&#39;Hello, great big round world&#39;</span>
</pre></div>
</div>
<p>This parser produces the correct result, &#8216;Hello, great big round world&#8217;.</p>
<dl class="class">
<dt id="parcon.Exact">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Exact</tt><big>(</big><em>self</em>, <em>parser</em>, <em>space_parser=Invalid()</em><big>)</big><a class="headerlink" href="#parcon.Exact" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Exact.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Exact.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Exact.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Exact.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Exact.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Exact.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Exact.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Exact.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Exact.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Exact.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Exact.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Exact.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Exact.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Exact.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Exact.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Exact.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Exact.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Exact.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Exact.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Exact.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Exact.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Exact.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-except">
<h2>Class Except<a class="headerlink" href="#class-except" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches and returns whatever the specified parser matches
and returns, as long as the specified avoid_parser does not also match at
the same location. For example, Except(AnyChar(), Literal(&#8220;<a href="#id1"><span class="problematic" id="id2">*</span></a>/&#8221;)) would
match any character as long as that character was not a * followed
immediately by a / character. This would most likely be useful in, for
example, a parser designed to parse C-style comments.</p>
<p>When this parser is converted to a railroad diagram, it simply replaces
itself with the underlying parser it wraps. The resulting railroad diagram
does not, therefore, mention the avoid parser, so you should be careful
that this is really what you want to do.</p>
<dl class="class">
<dt id="parcon.Except">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Except</tt><big>(</big><em>self</em>, <em>parser</em>, <em>avoid_parser</em><big>)</big><a class="headerlink" href="#parcon.Except" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Except.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Except.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Except.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Except.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Except.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Except.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Except.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Except.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Except.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Except.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Except.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Except.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Except.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Except.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Except.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Except.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Except.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Except.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Except.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Except.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Except.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Except.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-expectation">
<h2>Class Expectation<a class="headerlink" href="#class-expectation" title="Permalink to this headline">¶</a></h2>
<p>NOTE: Most users won&#8217;t need to know about this class or any of its
subclasses. They&#8217;re usually only used internally by Parcon, but advanced
users may wish to use them.</p>
<p>An expectation. Instances of the various subclasses of this class are
provided as part of a Result object to indicate what could have made a
parser succeed if it failed, or consume more input if it succeeded.
Expectations are used to format the error message when Parser.parse_string
throws an exception because of a parse error.</p>
<p>This class should not be instantiated directly; one of its various
subclasses should be used instead.</p>
<dl class="class">
<dt id="parcon.Expectation">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Expectation</tt><a class="headerlink" href="#parcon.Expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="method">
<dt id="parcon.Expectation.format">
<tt class="descname">format</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Expectation.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats this expectation into a human-readable string. For example,
EStringLiteral(&#8220;hello&#8221;).format() returns &#8216;&#8220;hello&#8221;&#8217;, and
EAnyCharIn(&#8220;abc&#8221;).format() returns &#8216;any char in &#8220;abc&#8221;&#8217;.</p>
<p>Subclasses must override this method; Expectation&#8217;s implementation of
the method raises NotImplementedError.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-expected">
<h2>Class Expected<a class="headerlink" href="#class-expected" title="Permalink to this headline">¶</a></h2>
<p>A parser that allows customization of the error message provided when the
parser it&#8217;s created with fails. For example, let&#8217;s say that you had a
parser that would parse numbers with decimals, such as 1.5:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span> <span class="o">=</span> <span class="o">+</span><span class="n">Digit</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="o">+</span><span class="n">Digit</span><span class="p">()</span>
</pre></div>
</div>
<p>Now let&#8217;s say that in your grammar, you included &#8220;true&#8221; and &#8220;false&#8221; as
things that could be in the same location as a decimal number:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">something</span> <span class="o">=</span> <span class="n">decimal</span> <span class="o">|</span> <span class="s">&quot;true&quot;</span> <span class="o">|</span> <span class="s">&quot;false&quot;</span>
</pre></div>
</div>
<p>If you call something.parse_string(&#8220;bogus&#8221;), the resulting error message
will be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">something</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;bogus&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">ParseException: Parse failure: At position 0</span>: <span class="n">expected one of any char in &quot;0123456789&quot;, &quot;true&quot;, &quot;false&quot;</span>
</pre></div>
</div>
<p>which isn&#8217;t very pretty or informative. If, instead, you did this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span> <span class="o">=</span> <span class="o">+</span><span class="n">Digit</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="o">+</span><span class="n">Digit</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span> <span class="o">=</span> <span class="n">Expected</span><span class="p">(</span><span class="n">decimal</span><span class="p">,</span> <span class="s">&quot;decimal number&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">something</span> <span class="o">=</span> <span class="n">decimal</span> <span class="o">|</span> <span class="s">&quot;true&quot;</span> <span class="o">|</span> <span class="s">&quot;false&quot;</span>
</pre></div>
</div>
<p>Then the error message would instead be something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">something</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;bogus&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">ParseException: Parse failure: At position 0</span>: <span class="n">expected one of decimal number, &quot;true&quot;, &quot;false&quot;</span>
</pre></div>
</div>
<p>which is more informative as to what&#8217;s missing.</p>
<p>If the parameter remove_whitespace is True when constructing an instance
of Expected, whitespace will be removed before calling the underlying
parser&#8217;s parse method. This will usually make error messages more accurate
about the position at which this whole Expected instance was expected.
If it&#8217;s False, whitespace will not be removed, and it will be up to the
underlying parser to remove it; as a result, error messages will indicate
the position /before/ the removed whitespace as where the error occurred,
which is usually not what you want.</p>
<dl class="class">
<dt id="parcon.Expected">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Expected</tt><big>(</big><em>self</em>, <em>parser</em>, <em>expected_message</em>, <em>remove_whitespace=True</em><big>)</big><a class="headerlink" href="#parcon.Expected" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Expected.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Expected.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Expected.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Expected.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Expected.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Expected.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-first">
<h2>Class First<a class="headerlink" href="#class-first" title="Permalink to this headline">¶</a></h2>
<p>A parser that tries all of its specified parsers in order. As soon as one
matches, its result is returned. If none of them match, this parser fails.</p>
<p>The parsers can be specified either as arguments (i.e. First(parser1,
parser2, parser3) or as a single list or tuple (i.e. First([parser1,
parser2, parser3]).</p>
<dl class="class">
<dt id="parcon.First">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">First</tt><big>(</big><em>self</em>, <em>*parsers</em><big>)</big><a class="headerlink" href="#parcon.First" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.First.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.First.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.First.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.First.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.First.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.First.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.First.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.First.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.First.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.First.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.First.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.First.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.First.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.First.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.First.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.First.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.First.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.First.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.First.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.First.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.First.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.First.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-forward">
<h2>Class Forward<a class="headerlink" href="#class-forward" title="Permalink to this headline">¶</a></h2>
<p>A parser that allows forward-definition. In other words, you can create a
Forward and use it in a parser grammar, and then set the parser that it
actually represents later on. This is useful for defining grammars that
need to include themselves (for example, parentheses in a numerical
expression contain yet another numberical expression, which is an example
of where this would be used).</p>
<p>You create a forward with something like this:</p>
<p>forward = Forward()</p>
<p>You can then use it in your grammar as you would a normal parser. When
you&#8217;re ready to set the parser that the Forward should actually represent,
you can do it either with:</p>
<p>forward &lt;&lt; parser</p>
<p>or with:</p>
<p>forward.set(parser)</p>
<p>Both of them cause the forward to act as if it was really just the
specified parser.</p>
<p>The parser must be set before parse is called on anything using the
Forward instance.</p>
<p>You can also specify the parser when you create the Forward instance. This
is usually somewhat pointless, but it can be useful if you&#8217;re simply trying
to create a mutable parser (the parser can be set into a Forward multiple
times, with the effect of changing the underlying parser each time).</p>
<dl class="class">
<dt id="parcon.Forward">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Forward</tt><big>(</big><em>self</em>, <em>parser=None</em><big>)</big><a class="headerlink" href="#parcon.Forward" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Forward.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Forward.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Forward.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Forward.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Forward.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Forward.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Forward.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Forward.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Forward.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Forward.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Forward.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Forward.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Forward.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Forward.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Forward.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Forward.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Forward.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Forward.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Forward.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Forward.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Forward.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Forward.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

<dl class="attribute">
<dt id="parcon.Forward.railroad_children">
<tt class="descname">railroad_children</tt><a class="headerlink" href="#parcon.Forward.railroad_children" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Forward.set">
<tt class="descname">set</tt><big>(</big><em>self</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.Forward.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the parser that this Forward should use. After you call this
method, this Forward acts just like it were really the specified parser.</p>
<p>This method can be called multiple times; each time it&#8217;s called, it
changes the parser in use by this Forward instance.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-infixexpr">
<h2>Class InfixExpr<a class="headerlink" href="#class-infixexpr" title="Permalink to this headline">¶</a></h2>
<p>A parser that&#8217;s created with a component parser and a series of operator
parsers, which can be literal strings (and will be translated to Literal
instances), and two-argument functions for each of these operator parsers.
It parses expressions of the form &#8220;component&#8221; or &#8220;component op component&#8221;
or &#8220;component op component op component&#8221; etc. For each op it encounters in
the result it parses, it calls the two-arg function supplied with that
operator, passing in the value of the parser on its left and the value of
the parser on its right. It then stores the result, and moves onto the next
operator, this time using the aforementioned result as the left-hand value
for the next operator.</p>
<p>This reduction of values proceeds from left to right, which makes InfixExpr
implement a left-associative infix grammar. In the future, there will be a
way to specify that certain operators should be right-associative instead.</p>
<p>If only a single component is present, InfixExpr will match that and return
whatever the component resulted in. If not even a single component is
present, InfixExpr will fail to match.</p>
<dl class="class">
<dt id="parcon.InfixExpr">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">InfixExpr</tt><big>(</big><em>self</em>, <em>component_parser</em>, <em>operators</em><big>)</big><a class="headerlink" href="#parcon.InfixExpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an InfixExpr. component_parser is the parser that will parse
the individual components of the expression. operators is a list of
2-tuples; each tuple represents an operator, with the first item in the
tuple being a parser that parses the operator itself (or a literal
string, such as &#8220;+&#8221;, &#8220;-&#8221;, etc, which will be wrapped with a Literal
instance) and the second item being a two-arg function that will be
used to reduce components on either side of the operator to get a
result.</p>
<dl class="method">
<dt id="parcon.InfixExpr.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.InfixExpr.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.InfixExpr.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.InfixExpr.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.InfixExpr.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.InfixExpr.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.InfixExpr.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.InfixExpr.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.InfixExpr.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.InfixExpr.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.InfixExpr.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.InfixExpr.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.InfixExpr.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.InfixExpr.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.InfixExpr.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.InfixExpr.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.InfixExpr.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.InfixExpr.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.InfixExpr.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.InfixExpr.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.InfixExpr.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.InfixExpr.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

<dl class="attribute">
<dt id="parcon.InfixExpr.railroad_children">
<tt class="descname">railroad_children</tt><a class="headerlink" href="#parcon.InfixExpr.railroad_children" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="class-invalid">
<h2>Class Invalid<a class="headerlink" href="#class-invalid" title="Permalink to this headline">¶</a></h2>
<p>A parser that never matches any input and always fails.</p>
<dl class="class">
<dt id="parcon.Invalid">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Invalid</tt><a class="headerlink" href="#parcon.Invalid" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="method">
<dt id="parcon.Invalid.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Invalid.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Invalid.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Invalid.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Invalid.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Invalid.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Invalid.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Invalid.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Invalid.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Invalid.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-keyword">
<h2>Class Keyword<a class="headerlink" href="#class-keyword" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches the specified parser as long as it is followed
immediately by the specified terminator parser, or by whitespace
(according to the current whitespace parser) if a terminator parser is not
specified.</p>
<p>If exact_terminator is True, the terminator is matched with Invalid() as
its whitespace parser. This prevents the whitespace parser from consuming
input that the terminator might have been expecting to see to indicate
proper termination of the keyword. If exact_terminator is False, the same
whitespace parser passed to Keyword will be passed into the terminator.</p>
<p>If or_end is True, the terminator will be replaced with
(terminator | End()) just before attempting to parse it, which would allow
the keyword to be present at the end of the input without causing a parse
failure due to the keyword not being followed immediately by the
terminator.</p>
<dl class="class">
<dt id="parcon.Keyword">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Keyword</tt><big>(</big><em>self</em>, <em>parser</em>, <em>terminator=None</em>, <em>exact_terminator=True</em>, <em>or_end=True</em><big>)</big><a class="headerlink" href="#parcon.Keyword" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Keyword.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Keyword.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Keyword.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Keyword.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Keyword.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Keyword.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Keyword.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Keyword.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Keyword.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Keyword.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Keyword.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Keyword.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Keyword.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Keyword.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Keyword.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Keyword.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Keyword.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Keyword.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Keyword.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Keyword.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Keyword.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Keyword.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-limit">
<h2>Class Limit<a class="headerlink" href="#class-limit" title="Permalink to this headline">¶</a></h2>
<p>A parser that imposes a limit on how much input its underlying parser can
consume. All parsers, when asked to parse text, are passed the position
that they can parse to before they have to stop; normally this is the length
of the string being passed in. Limit, however, allows this to be set to a
smaller value.</p>
<p>When you construct a Limit instance, you pass in a parser that it will
call and the number of characters that the specified parser can consume.
If there aren&#8217;t that many characters left in the input string, no limit is
placed on what the specified parser can consume.</p>
<p>You can also pass a parser instead of a number as the limit for how many
characters can be parsed. If you do that, Limit will apply that parser
first, then take its result (which should be an int or a long) and use
that as the limit when applying the main parser.</p>
<p>The behavior of the latter paragraph allows you to write parsers that
parse length-specified values. For example, if you&#8217;re parsing some sort of
string from a piece of binary data where the string is stored as four
bytes representing the length of the string followed by the bytes of the
string itself, you could do that with
Limit(parcon.binary.integer, ZeroOrMore(AnyChar()))[concat].</p>
<dl class="class">
<dt id="parcon.Limit">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Limit</tt><big>(</big><em>self</em>, <em>length</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.Limit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Limit.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Limit.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Limit.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Limit.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Limit.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Limit.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-literal">
<h2>Class Literal<a class="headerlink" href="#class-literal" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches the specified literal piece of text. It succeeds
only if that piece of text is found, and it returns None when it succeeds.
If you need the return value to be the literal piece of text, you should
probably use SignificantLiteral instead.</p>
<dl class="class">
<dt id="parcon.Literal">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Literal</tt><big>(</big><em>self</em>, <em>text</em><big>)</big><a class="headerlink" href="#parcon.Literal" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Literal.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Literal.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Literal.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Literal.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Literal.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Literal.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Literal.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Literal.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Literal.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Literal.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Literal.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Literal.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Literal.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Literal.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Literal.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Literal.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Literal.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Literal.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Literal.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Literal.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Literal.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Literal.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-longest">
<h2>Class Longest<a class="headerlink" href="#class-longest" title="Permalink to this headline">¶</a></h2>
<p>A parser that tries all of its specified parsers. The longest one that
succeeds is chosen, and its result is returned. If none of the parsers
succeed, Longest fails.</p>
<p>The parsers can be specified either as arguments (i.e. First(parser1,
parser2, parser3) or as a single list or tuple (i.e. First([parser1,
parser2, parser3]).</p>
<p>Longest is typically more expensive than First since it has to try each
parser to see which one consumes the most input whereas First stops trying
parsers once one succeeds. Because of this, it&#8217;s usually better to use
First if the parsers to check can be reordered so that those consuming the
most input are at the beginning of the list.</p>
<dl class="class">
<dt id="parcon.Longest">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Longest</tt><big>(</big><em>self</em>, <em>*parsers</em><big>)</big><a class="headerlink" href="#parcon.Longest" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Longest.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Longest.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Longest.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Longest.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Longest.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Longest.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Longest.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Longest.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Longest.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Longest.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Longest.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Longest.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Longest.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Longest.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Longest.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Longest.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Longest.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Longest.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Longest.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Longest.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Longest.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Longest.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-lower">
<h2>Class Lower<a class="headerlink" href="#class-lower" title="Permalink to this headline">¶</a></h2>
<p>Same as CharIn(lower_chars).</p>
<dl class="class">
<dt id="parcon.Lower">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Lower</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Lower" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Lower.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Lower.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Lower.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Lower.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Lower.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Lower.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Lower.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Lower.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Lower.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Lower.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Lower.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Lower.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Lower.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Lower.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Lower.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Lower.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Lower.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Lower.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Lower.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Lower.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Lower.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Lower.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-name">
<h2>Class Name<a class="headerlink" href="#class-name" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="parcon.Name">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Name</tt><big>(</big><em>self</em>, <em>name</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.Name" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Name.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Name.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Name.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Name.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Name.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Name.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Name.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Name.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Name.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Name.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Name.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Name.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Name.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Name.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Name.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Name.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Name.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Name.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Name.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Name.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Name.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Name.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-not">
<h2>Class Not<a class="headerlink" href="#class-not" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches only if the parser it&#8217;s created with does not. If the
aforementioned parser fails, then Not succeeds, consuming no input and
returning None. If the aforementioned parser succeeds, then Not fails.</p>
<dl class="class">
<dt id="parcon.Not">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Not</tt><big>(</big><em>self</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.Not" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Not.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Not.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Not.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Not.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Not.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Not.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Not.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Not.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Not.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Not.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-oneormore">
<h2>Class OneOrMore<a class="headerlink" href="#class-oneormore" title="Permalink to this headline">¶</a></h2>
<p>Same as ZeroOrMore, but requires that the specified parser match at least
once. If it does not, this parser will fail.</p>
<dl class="class">
<dt id="parcon.OneOrMore">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">OneOrMore</tt><big>(</big><em>self</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.OneOrMore" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.OneOrMore.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.OneOrMore.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.OneOrMore.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.OneOrMore.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.OneOrMore.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.OneOrMore.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.OneOrMore.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.OneOrMore.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.OneOrMore.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.OneOrMore.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.OneOrMore.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.OneOrMore.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.OneOrMore.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.OneOrMore.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.OneOrMore.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.OneOrMore.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.OneOrMore.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.OneOrMore.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.OneOrMore.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.OneOrMore.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.OneOrMore.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.OneOrMore.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-optional">
<h2>Class Optional<a class="headerlink" href="#class-optional" title="Permalink to this headline">¶</a></h2>
<p>A parser that returns whatever its underlying parser returns, except that
if the specified parser fails, this parser succeeds and returns the default
result specified to it (which, itself, defaults to None).</p>
<dl class="class">
<dt id="parcon.Optional">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Optional</tt><big>(</big><em>self</em>, <em>parser</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#parcon.Optional" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Optional.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Optional.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Optional.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Optional.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Optional.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Optional.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Optional.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Optional.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Optional.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Optional.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Optional.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Optional.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Optional.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Optional.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Optional.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Optional.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Optional.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Optional.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Optional.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Optional.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Optional.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Optional.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-pair">
<h2>Class Pair<a class="headerlink" href="#class-pair" title="Permalink to this headline">¶</a></h2>
<p>Pair(key, value)</p>
<dl class="class">
<dt id="parcon.Pair">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Pair</tt><a class="headerlink" href="#parcon.Pair" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="attribute">
<dt id="parcon.Pair.key">
<tt class="descname">key</tt><a class="headerlink" href="#parcon.Pair.key" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="parcon.Pair.value">
<tt class="descname">value</tt><a class="headerlink" href="#parcon.Pair.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-parseexception">
<h2>Class ParseException<a class="headerlink" href="#class-parseexception" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="parcon.ParseException">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">ParseException</tt><big>(</big><em>self</em>, <em>message</em>, <em>expectations=None</em><big>)</big><a class="headerlink" href="#parcon.ParseException" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="class-parser">
<h2>Class Parser<a class="headerlink" href="#class-parser" title="Permalink to this headline">¶</a></h2>
<p>A parser. This class cannot itself be instantiated; you can only use one of
its subclasses. Most classes in this module are Parser subclasses.</p>
<p>The method you&#8217;ll typically use on Parser objects is parse_string.</p>
<dl class="class">
<dt id="parcon.Parser">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Parser</tt><a class="headerlink" href="#parcon.Parser" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="method">
<dt id="parcon.Parser.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Parser.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Parser.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Parser.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Parser.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Parser.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-present">
<h2>Class Present<a class="headerlink" href="#class-present" title="Permalink to this headline">¶</a></h2>
<p>A lookahead parser; it matches as long as the parser it&#8217;s constructed with
matches at the specified position, but it doesn&#8217;t actually consume any
input, and its result is None. If you need access to the result, you&#8217;ll
probably want to use Preserve instead.</p>
<dl class="class">
<dt id="parcon.Present">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Present</tt><big>(</big><em>self</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.Present" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Present.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Present.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Present.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Present.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Present.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Present.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Present.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Present.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Present.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Present.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-preserve">
<h2>Class Preserve<a class="headerlink" href="#class-preserve" title="Permalink to this headline">¶</a></h2>
<p>A lookahead parser; it matches as long as the parser it&#8217;s constructed with
matches at the specified position, but it doesn&#8217;t actually consume any
input. Unlike Present, however, Preserve returns whatever its underlying
parser returned, even though it doesn&#8217;t consume any input.</p>
<dl class="class">
<dt id="parcon.Preserve">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Preserve</tt><big>(</big><em>self</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.Preserve" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Preserve.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Preserve.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Preserve.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Preserve.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Preserve.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Preserve.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Preserve.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Preserve.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Preserve.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Preserve.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-regex">
<h2>Class Regex<a class="headerlink" href="#class-regex" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches the specified regular expression. Its result depends
on the groups_only parameter passed to the constructor: if groups_only is
None (the default), the result is the string that the regex matches. If
groups_only is True, a list of the values that the groups in the regex
matched is true; for example, Regex(&#8220;(..)(.)(....)&#8221;, groups_only=True)
would parse the string &#8220;abcdefg&#8221; into [&#8220;ab&#8221;, &#8220;c&#8221;, &#8220;defg&#8221;]. If groups_only
is False, the string that the regex matched is provided as the first item
in the list, and the groups are provided as the rest of the items in the
list; the above example with groups_only=False would parse the string
&#8220;abcdefg&#8221; into [&#8220;abcdefg&#8221;, &#8220;ab&#8221;, &#8220;c&#8221;, &#8220;defg&#8221;].</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Regex</span><span class="p">(</span><span class="s">&quot;(..)(.)(....)&quot;</span><span class="p">,</span> <span class="n">groups_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;abcdefg&quot;</span><span class="p">)</span>
<span class="go">[&#39;ab&#39;, &#39;c&#39;, &#39;defg&#39;]</span>
</pre></div>
</div>
<p>If you can avoid using Regex without requiring exorbitant amounts of
additional code, it&#8217;s generally best to, since error messages given by
combinations of Parcon parsers are generally more informative than an
error message providing a regex. If you really need to use Regex but you
still want informative error messages, you could wrap your Regex instance
in an instance of Expected.</p>
<p>The specified regex can be either a string representing the regular
expression or a pattern compiled with Python&#8217;s re.compile. If you want to
specify flags to the regex, you&#8217;ll need to compile it with re.compile, then
pass the result into Regex.</p>
<p>Unlike the behavior of normal Python regex groups, groups that did not
participate in a match are represented in the returned list (if
groups_only is not None) by the empty string instead of None. If enough
people want the ability for None to be used instead (and my email address
is in the docstring for this module, at the top, so send me an email if
you&#8217;re one of the people that want this), I&#8217;ll add a parameter that can be
passed to Regex to switch this back to the usual behavior of using None.</p>
<dl class="class">
<dt id="parcon.Regex">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Regex</tt><big>(</big><em>self</em>, <em>regex</em>, <em>groups_only=None</em><big>)</big><a class="headerlink" href="#parcon.Regex" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Regex.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Regex.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Regex.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Regex.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Regex.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Regex.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Regex.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Regex.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Regex.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Regex.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Regex.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Regex.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Regex.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Regex.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Regex.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Regex.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Regex.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Regex.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-repeat">
<h2>Class Repeat<a class="headerlink" href="#class-repeat" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches its underlying parser a certain number of times. If
the underlying parser did not match at least min times, this parser fails.
This parser stops parsing after max times, even if the underlying parser
would still match. The results of all of the parses are returned as a list.</p>
<p>If max is None, no maximum limit will be enforced. The same goes for min.</p>
<p>Repeat(parser, 0, None) is the same as ZeroOrMore(parser), and
Repeat(parser, 1, None) is the same as OneOrMore(parser).</p>
<dl class="class">
<dt id="parcon.Repeat">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Repeat</tt><big>(</big><em>self</em>, <em>parser</em>, <em>min</em>, <em>max</em><big>)</big><a class="headerlink" href="#parcon.Repeat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Repeat.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Repeat.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Repeat.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Repeat.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Repeat.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Repeat.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Repeat.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Repeat.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Repeat.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Repeat.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-result">
<h2>Class Result<a class="headerlink" href="#class-result" title="Permalink to this headline">¶</a></h2>
<p>A result from a parser. Parcon users usually won&#8217;t have any use for
instances of this class since it&#8217;s primarily used internally by Parcon, but
if you&#8217;re implementing your own Parser subclass, then you&#8217;ll likely find
this class useful since you&#8217;ll be returning instances of it.</p>
<p>You typically don&#8217;t create instances of Result directly; instead, you
usually call either match() or failure(), which return result objects
indicating success or failure, respectively.</p>
<p>Three fields are made available on a Result object:</p>
<blockquote>
<div><p>expected: A list of expectations in the same format as provided to the
failure() function</p>
<p>end: The position at which the parser finished parsing, if this result
indicates success. The value is undefined in the case of a failure.</p>
<p>value: The value that the parser produced, if this result indicates
success. The value is undefined in the case of a failure.</p>
</div></blockquote>
<p>You can test whether or not a result indicates success by using it as a
boolean. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">successful_result</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;some random value&quot;</span><span class="p">,</span> <span class="p">[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">failed_result</span> <span class="o">=</span> <span class="n">failure</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EUnsatisfiable</span><span class="p">())])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">successful_result</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;Yes&quot;</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;No&quot;</span>
<span class="gp">...</span>
<span class="go">Yes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">failed_result</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;Yes&quot;</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;No&quot;</span>
<span class="gp">...</span>
<span class="go">No</span>
</pre></div>
</div>
<dl class="class">
<dt id="parcon.Result">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Result</tt><big>(</big><em>self</em>, <em>end</em>, <em>value</em>, <em>expected</em><big>)</big><a class="headerlink" href="#parcon.Result" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="class-return">
<h2>Class Return<a class="headerlink" href="#class-return" title="Permalink to this headline">¶</a></h2>
<p>A parser that always succeeds, consumes no input, and always returns a
value specified when the Return instance is constructed.</p>
<p>Those of you familiar with functional programming will notice that this
parser implements a monadic return, hence its name.</p>
<dl class="class">
<dt id="parcon.Return">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Return</tt><big>(</big><em>self</em>, <em>value</em><big>)</big><a class="headerlink" href="#parcon.Return" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Return.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Return.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Return.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Return.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Return.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Return.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Return.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Return.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Return.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Return.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Return.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Return.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Return.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Return.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Return.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Return.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Return.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Return.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Return.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>whitespace</em><big>)</big><a class="headerlink" href="#parcon.Return.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Return.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Return.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-significantliteral">
<h2>Class SignificantLiteral<a class="headerlink" href="#class-significantliteral" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches the specified literal piece of text. Is succeeds
only if that piece of text is found. Unlike Literal, however,
SignificantLiteral returns the literal string passed into it instead of
None.</p>
<dl class="class">
<dt id="parcon.SignificantLiteral">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">SignificantLiteral</tt><big>(</big><em>self</em>, <em>text</em><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.SignificantLiteral.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.SignificantLiteral.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.SignificantLiteral.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.SignificantLiteral.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.SignificantLiteral.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.SignificantLiteral.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.SignificantLiteral.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.SignificantLiteral.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.SignificantLiteral.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.SignificantLiteral.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.SignificantLiteral.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.SignificantLiteral.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-tag">
<h2>Class Tag<a class="headerlink" href="#class-tag" title="Permalink to this headline">¶</a></h2>
<p>A parser that &#8220;tags&#8221;, so to speak, the value returned from its underlying
parser. Specifically, you construct a Tag instance by specifying a tag and
a parser, and the specified parser&#8217;s return value will be wrapped in a
Pair(tag, return_value). For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Tag</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">AnyChar</span><span class="p">())</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="go">Pair(key=&#39;test&#39;, value=&#39;a&#39;)</span>
</pre></div>
</div>
<p>The reason why this is useful is that named tuples are treated as objects
by Parcon things like Then and the flatten function, so they will be passed
around as objects, but they are treated as tuples by Python&#8217;s dict
function. This allows you to use various parsers that assemble values
passed through Tag, and then add [flatten][dict] onto the end of that whole
parser group; the result of that parser will be a dictionary containing all
of the tagged values, with the tags as keys. For example, a parser that
parses numbers such as &#8220;123.45&#8221; into a dict of the form {&#8220;integer&#8221;: &#8220;123&#8221;,
&#8220;decimal&#8221;: &#8220;45&#8221;} could be written as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">decimal_parser</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tag</span><span class="p">(</span><span class="s">&quot;integer&quot;</span><span class="p">,</span> <span class="p">(</span><span class="o">+</span><span class="n">Digit</span><span class="p">())[</span><span class="n">concat</span><span class="p">])</span> <span class="o">+</span> <span class="n">Tag</span><span class="p">(</span><span class="s">&quot;decimal&quot;</span><span class="p">,</span>                              <span class="n">Optional</span><span class="p">(</span><span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="o">+</span><span class="n">Digit</span><span class="p">())[</span><span class="n">concat</span><span class="p">],</span> <span class="s">&quot;&quot;</span><span class="p">)))[</span><span class="nb">dict</span><span class="p">]</span>
</pre></div>
</div>
<p>Of course, using the short notation parser[&#8220;tag&#8221;] in place of Tag(&#8220;tag&#8221;,
parser), we can reduce that further to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">decimal_parser</span> <span class="o">=</span> <span class="p">((</span><span class="o">+</span><span class="n">Digit</span><span class="p">())[</span><span class="n">concat</span><span class="p">][</span><span class="s">&quot;integer&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="s">&quot;.&quot;</span> <span class="o">+</span>                              <span class="p">(</span><span class="o">+</span><span class="n">Digit</span><span class="p">())[</span><span class="n">concat</span><span class="p">],</span> <span class="s">&quot;&quot;</span><span class="p">)[</span><span class="s">&quot;decimal&quot;</span><span class="p">])[</span><span class="nb">dict</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that the short notation of parser[tag] only works if tag is a string
(or a unicode instance; anything that subclasses from basestring works).
No other datatypes will work; if you want to use those, you&#8217;ll need to use
Tag itself instead of the short notation.</p>
<p>If you want to preserve all values with a particular tag instead of just
one of them, you may want to use parser[list_dict] instead of parser[dict].
See the documentation for list_dict for more on what it does.</p>
<dl class="class">
<dt id="parcon.Tag">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Tag</tt><big>(</big><em>self</em>, <em>tag</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.Tag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Tag.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Tag.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Tag.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Tag.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Tag.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Tag.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Tag.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Tag.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Tag.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Tag.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Tag.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Tag.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Tag.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Tag.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Tag.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Tag.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Tag.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Tag.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Tag.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Tag.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Tag.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Tag.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-then">
<h2>Class Then<a class="headerlink" href="#class-then" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches the first specified parser followed by the second.
If neither of them matches, or if only one of them matches, this parser
fails. If both of them match, the result is as follows, assuming A and B
are the results of the first and the second parser, respectively:</p>
<p>If A is None, the result is B.
If B is None, the result is A.
If A and B are tuples, the result is A + B.
If A is a tuple but B is not, the result is A + (B,).
If B is a tuple but A is not, the result is (A,) + B.
Otherwise, the result is (A, B).</p>
<p>Named tuples (instances of classes created with collections.namedtuple) are
not treated as tuples in the above decision process. In fact, any subclass
of tuple is treated as if it were a completely separate object and not a
tuple at all.</p>
<dl class="class">
<dt id="parcon.Then">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Then</tt><big>(</big><em>self</em>, <em>first</em>, <em>second</em><big>)</big><a class="headerlink" href="#parcon.Then" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Then.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Then.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Then.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Then.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Then.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Then.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Then.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Then.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Then.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Then.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Then.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Then.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Then.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Then.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Then.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Then.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Then.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Then.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Then.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Then.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Then.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Then.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-translate">
<h2>Class Translate<a class="headerlink" href="#class-translate" title="Permalink to this headline">¶</a></h2>
<p>A parser that passes the result of the parser it&#8217;s created with, if said
parser matches successfully, through a function, and the function&#8217;s return
value is then used as the result. The function is not called if the
specified parser fails.</p>
<p>For example, the following parser would use the flatten function provided
by parcon to flatten any lists and tuples produced by the parser
example_parser:</p>
<p>Translate(example_parser, flatten)</p>
<p>The following parser would likewise expect another_parser to produce a list
of strings and concatenate them together into a single result string:</p>
<p>Translate(another_parser, &#8220;&#8221;.join)</p>
<dl class="class">
<dt id="parcon.Translate">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Translate</tt><big>(</big><em>self</em>, <em>parser</em>, <em>function</em><big>)</big><a class="headerlink" href="#parcon.Translate" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Translate.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Translate.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Translate.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Translate.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Translate.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Translate.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Translate.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Translate.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Translate.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Translate.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Translate.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Translate.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Translate.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Translate.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Translate.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Translate.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Translate.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Translate.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Translate.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Translate.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Translate.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Translate.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-upper">
<h2>Class Upper<a class="headerlink" href="#class-upper" title="Permalink to this headline">¶</a></h2>
<p>Same as CharIn(upper_chars).</p>
<dl class="class">
<dt id="parcon.Upper">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Upper</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Upper" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Upper.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Upper.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Upper.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Upper.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Upper.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Upper.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Upper.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Upper.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Upper.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Upper.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Upper.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Upper.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Upper.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Upper.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Upper.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Upper.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Upper.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Upper.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Upper.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Upper.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Upper.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Upper.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-whitespace">
<h2>Class Whitespace<a class="headerlink" href="#class-whitespace" title="Permalink to this headline">¶</a></h2>
<p>Same as CharIn(whitespace).</p>
<dl class="class">
<dt id="parcon.Whitespace">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Whitespace</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Whitespace" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Whitespace.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Whitespace.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Whitespace.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.Whitespace.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Whitespace.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.Whitespace.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Whitespace.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.Whitespace.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Whitespace.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Whitespace.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Whitespace.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.Whitespace.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Whitespace.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.Whitespace.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Whitespace.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Whitespace.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Whitespace.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.Whitespace.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.Whitespace.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Whitespace.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Whitespace.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Whitespace.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-word">
<h2>Class Word<a class="headerlink" href="#class-word" title="Permalink to this headline">¶</a></h2>
<p>A parser that parses a word consisting of a certain set of allowed
characters. A minimum and maximum word length can also be specified, as can
a set of characters of which the first character in the word must be a
member.</p>
<p>If min is unspecified, it defaults to 1. Max defaults to None, which places
no upper limit on the number of characters that can be in this word.</p>
<p>Word parses as many characters as it can that are in the specified
character set until it&#8217;s parsed the specified maximum number of characters,
or it hits a character not in the specified character set. If, at that
point, the number of characters parsed is less than min, this parser fails.
Otherwise, it succeeds and produces a string containing all the characters.</p>
<p>min can be zero, which will allow this parser to succeed even if there are
no characters available or if the first character is not in init_chars.
The empty string will be returned in such a case.</p>
<dl class="class">
<dt id="parcon.Word">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">Word</tt><big>(</big><em>self</em>, <em>chars</em>, <em>init_chars=None</em>, <em>min=1</em>, <em>max=None</em><big>)</big><a class="headerlink" href="#parcon.Word" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.Word.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.Word.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Word.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.Word.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.Word.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.Word.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-zeroormore">
<h2>Class ZeroOrMore<a class="headerlink" href="#class-zeroormore" title="Permalink to this headline">¶</a></h2>
<p>A parser that matches the specified parser as many times as it can. The
results are collected into a list, which is then returned. Since
ZeroOrMore succeeds even if zero matches were made (the empty list will
be returned in such a case), this parser always succeeds.</p>
<dl class="class">
<dt id="parcon.ZeroOrMore">
<em class="property">class </em><tt class="descclassname">parcon.</tt><tt class="descname">ZeroOrMore</tt><big>(</big><em>self</em>, <em>parser</em><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="parcon.ZeroOrMore.consume">
<tt class="descname">consume</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.consume" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.ZeroOrMore.create_railroad">
<tt class="descname">create_railroad</tt><big>(</big><em>self</em>, <em>options</em><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.create_railroad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.ZeroOrMore.do_graph">
<tt class="descname">do_graph</tt><big>(</big><em>self</em>, <em>graph</em><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.do_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.ZeroOrMore.draw_productions_to_image">
<tt class="descname">draw_productions_to_image</tt><big>(</big><em>self</em>, <em>img_type</em>, <em>options</em>, <em>filename</em>, <em>tail</em><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.draw_productions_to_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.ZeroOrMore.draw_productions_to_png">
<tt class="descname">draw_productions_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.draw_productions_to_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.ZeroOrMore.draw_productions_to_svg">
<tt class="descname">draw_productions_to_svg</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em>, <em>tail=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.draw_productions_to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.ZeroOrMore.draw_railroad_to_png">
<tt class="descname">draw_railroad_to_png</tt><big>(</big><em>self</em>, <em>options</em>, <em>filename</em><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.draw_railroad_to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a syntax diagram for this object to the specified .png image file
using the specified options. For now, just pass {} (i.e. an empty
dictionary) as options; I&#8217;ll document what this actually does at a
later date.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.ZeroOrMore.get_productions">
<tt class="descname">get_productions</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.get_productions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.ZeroOrMore.graph">
<tt class="descname">graph</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphs this Graphable object by calling its do_graph and the do_graph
functions defined by all of the things that this Graphable depends on.
The result will be a Graph object.</p>
<p>Each node in the resulting Graph will be named after its respective
object&#8217;s identity, a.k.a. the value returned by the built-in id
function.</p>
<p>The quickest way to use this would be to do something like this:</p>
<p>something.graph().draw(&#8220;example.png&#8221;)</p>
<p>For the draw method to work, however, you must have the dot program
(which is part of Graphviz) installed.</p>
</dd></dl>

<dl class="method">
<dt id="parcon.ZeroOrMore.parse">
<tt class="descname">parse</tt><big>(</big><em>self</em>, <em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="parcon.ZeroOrMore.parse_string">
<tt class="descname">parse_string</tt><big>(</big><em>self</em>, <em>string</em>, <em>all=True</em>, <em>whitespace=None</em><big>)</big><a class="headerlink" href="#parcon.ZeroOrMore.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a string using this parser and returns the result, or throws an
exception if the parser does not match. If all is True (the default),
an exception will be thrown if this parser does not match all of the
input. Otherwise, if the parser only matches a portion of the input
starting at the beginning, just that portion will be returned.</p>
<p>whitespace is the whitespace parser to use; this parser will be applied
(and its results discarded) between matching every other parser while
attempting to parse the specified string. A typical grammar might have
this parser represent whitespace and comments. An instance of Exact can
be used to suppress whitespace parsing for a portion of the grammar,
which you would most likely use in, for example, string literals. The
default value for this parameter is Whitespace().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="parcon.concat">
<tt class="descclassname">parcon.</tt><tt class="descname">concat</tt><big>(</big><em>value</em>, <em>delimiter=''</em><big>)</big><a class="headerlink" href="#parcon.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Walks through value, which should be a list or a tuple potentially
containing other lists/tuples, and extracts all strings from it (and
recursively from any other lists/tuples that it contains). These strings
are then concatenated using the specified delimiter.</p>
<p>Right now, this delegates to flatten to flatten out the specified value. It
then iterates over all of the items in the resulting list and concatenates
all of them that are strings.</p>
</dd></dl>

<dl class="function">
<dt id="parcon.failure">
<tt class="descclassname">parcon.</tt><tt class="descname">failure</tt><big>(</big><em>expected</em><big>)</big><a class="headerlink" href="#parcon.failure" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Result representing a failure of a parser to match. expected is
a list of expectations that would have had to be satisfied in the text
passed to the parser calling this method in order for it to potentially
succeed. Expectations are 2-tuples of the position at which some particular
piece of text was expected and an instance of one of the subclasses of
Expectation describing what was expected.</p>
</dd></dl>

<dl class="function">
<dt id="parcon.filter_expectations">
<tt class="descclassname">parcon.</tt><tt class="descname">filter_expectations</tt><big>(</big><em>expected</em><big>)</big><a class="headerlink" href="#parcon.filter_expectations" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the expectations from the specified expectation list, which should
be of the same format as that passed to failure(), that have the maximum
position within the list. A tuple (position, expectations) will then be
returned, where position is the maximum position and expectations is the
list of expectations at that position.</p>
<p>If the specified list is empty, (0, []) will be returned.</p>
<p>All instances of EUnsatisfiable will be filtered from the expectation list,
unless it consists only of EUnsatisfiable instances. In that case, only a
single EUnsatisfiable will be present in the returned expectation list,
even if there were more than one at the maximum position.</p>
</dd></dl>

<dl class="function">
<dt id="parcon.flatten">
<tt class="descclassname">parcon.</tt><tt class="descname">flatten</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#parcon.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>A function that recursively flattens the specified value. Tuples and lists
are flattened into the items that they contain. The result is a list.</p>
<p>If a single non-list, non-tuple value is passed in, the result is a list
containing just that item. If, however, that value is None, the result is
the empty list.</p>
<p>This function is intended to be used as the function passed to Translate
where the parser passed to Translate could produce multiple nested lists of
tuples and lists, and a single, flat, list is desired.</p>
<p>Named tuples (instances of classes created with collections.namedtuple) are
treated as normal object, not tuples, so they will not be flattened.</p>
</dd></dl>

<dl class="function">
<dt id="parcon.format_expectations">
<tt class="descclassname">parcon.</tt><tt class="descname">format_expectations</tt><big>(</big><em>position</em>, <em>expectations</em><big>)</big><a class="headerlink" href="#parcon.format_expectations" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats a position and a list of strings into a failure message that
typically looks like this:</p>
<p>At position n: expected one of x, y, z</p>
<p>Position is the position to use for n. Expectations is the list of strings
to use for x, y, and z.</p>
<p>Note that if there is only one expectation, the message will instead look
like:</p>
<p>At position n: expected x</p>
</dd></dl>

<dl class="function">
<dt id="parcon.format_failure">
<tt class="descclassname">parcon.</tt><tt class="descname">format_failure</tt><big>(</big><em>expected</em><big>)</big><a class="headerlink" href="#parcon.format_failure" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats a list of expectations into a failure message that typically looks
something like this:</p>
<p>At position n: expected one of x, y, z</p>
<p>Expectations are provided in the same format as passed to the failure()
function.</p>
<p>This function used to contain all of the formatting logic, but the logic
has since been split into the functions filter_expectations,
stringify_expectations, and format_expectations. This function now
functions as a convenience wrapper around those three functions.</p>
</dd></dl>

<dl class="function">
<dt id="parcon.list_dict">
<tt class="descclassname">parcon.</tt><tt class="descname">list_dict</tt><big>(</big><em>list_of_pairs</em><big>)</big><a class="headerlink" href="#parcon.list_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to dict(list_of_pairs), but the values in the returned dict are
lists containing one item for each pair with the specified key. In other
words, this can be used to convert a list of 2-tuples into a dict where the
same key might be present twice (or more) in the specified list; the value
list in the resulting dict will have two (or more) items in it.</p>
<p>This is intended to be used as parser[list_dict] in place of parser[dict]
when all of the items with a particular tag need to be preserved; this is
Parcon&#8217;s equivalent to Pyparsing&#8217;s setResultsName(..., listAllMatches=True)
behavior.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># The last tuple wins:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;one&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;two&quot;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;first&quot;</span><span class="p">)])</span>
<span class="go">{1: &#39;first&#39;, 2: &#39;two&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># All results included in lists:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">list_dict</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;one&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;two&quot;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;first&quot;</span><span class="p">)])</span>
<span class="go">{1: [&#39;one&#39;, &#39;first&#39;], 2: [&#39;two&#39;]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="parcon.match">
<tt class="descclassname">parcon.</tt><tt class="descname">match</tt><big>(</big><em>end</em>, <em>value</em>, <em>expected</em><big>)</big><a class="headerlink" href="#parcon.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Result representing a parser successfully matching. end is the
position in the string just after where the parser finished, or rather,
where the next parser after this one would be expected to start parsing.
value is the value that this parser resulted in, which is typically
specific to the parser calling this function. expected is a list of
expectations that would have allowed this parser to match more input than
it did; this parameter takes the same format as its corresponding parameter
to the failure function.</p>
</dd></dl>

<dl class="function">
<dt id="parcon.op_add">
<tt class="descclassname">parcon.</tt><tt class="descname">op_add</tt><big>(</big><em>first</em>, <em>second</em><big>)</big><a class="headerlink" href="#parcon.op_add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="parcon.op_and">
<tt class="descclassname">parcon.</tt><tt class="descname">op_and</tt><big>(</big><em>first</em>, <em>second</em><big>)</big><a class="headerlink" href="#parcon.op_and" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="parcon.op_call">
<tt class="descclassname">parcon.</tt><tt class="descname">op_call</tt><big>(</big><em>parser</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#parcon.op_call" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="parcon.op_getitem">
<tt class="descclassname">parcon.</tt><tt class="descname">op_getitem</tt><big>(</big><em>parser</em>, <em>function</em><big>)</big><a class="headerlink" href="#parcon.op_getitem" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="parcon.op_invert">
<tt class="descclassname">parcon.</tt><tt class="descname">op_invert</tt><big>(</big><em>parser</em><big>)</big><a class="headerlink" href="#parcon.op_invert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="parcon.op_neg">
<tt class="descclassname">parcon.</tt><tt class="descname">op_neg</tt><big>(</big><em>parser</em><big>)</big><a class="headerlink" href="#parcon.op_neg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="parcon.op_or">
<tt class="descclassname">parcon.</tt><tt class="descname">op_or</tt><big>(</big><em>first</em>, <em>second</em><big>)</big><a class="headerlink" href="#parcon.op_or" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="parcon.op_pos">
<tt class="descclassname">parcon.</tt><tt class="descname">op_pos</tt><big>(</big><em>parser</em><big>)</big><a class="headerlink" href="#parcon.op_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="parcon.op_sub">
<tt class="descclassname">parcon.</tt><tt class="descname">op_sub</tt><big>(</big><em>first</em>, <em>second</em><big>)</big><a class="headerlink" href="#parcon.op_sub" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="parcon.parse_space">
<tt class="descclassname">parcon.</tt><tt class="descname">parse_space</tt><big>(</big><em>text</em>, <em>position</em>, <em>end</em>, <em>space</em><big>)</big><a class="headerlink" href="#parcon.parse_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeatedly applies the specified whitespace parser to the specified text
starting at the specified position until it no longer matches. The result
of all of these parses will be discarded, and the location at which the
whitespace parser failed will be returned.</p>
</dd></dl>

<dl class="function">
<dt id="parcon.promote">
<tt class="descclassname">parcon.</tt><tt class="descname">promote</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#parcon.promote" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a value of some type to an appropriate parser. Right now, this
returns the value as is if it&#8217;s an instance of Parser, or Literal(value) if
the value is a string.</p>
</dd></dl>

<dl class="function">
<dt id="parcon.separated">
<tt class="descclassname">parcon.</tt><tt class="descname">separated</tt><big>(</big><em>item_parser</em>, <em>separator_parser</em><big>)</big><a class="headerlink" href="#parcon.separated" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and returns a parser that will parse one or more items parsed by
item_parser, separated by separator_parser. The result of the parser is a
list of the items produced by item_parser.</p>
<p>Both item_parser and separator_parser will be automatically promote()d, so
a string such as &#8221;,&#8221;, for example, could be used as separator_parser
without having to wrap it in a Literal first.</p>
</dd></dl>

<dl class="function">
<dt id="parcon.stringify_expectations">
<tt class="descclassname">parcon.</tt><tt class="descname">stringify_expectations</tt><big>(</big><em>expectations</em><big>)</big><a class="headerlink" href="#parcon.stringify_expectations" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the specified list of Expectation objects into a list of strings.
This essentially just returns [e.format() for e in expectations].</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">parcon</span></tt> &#8212; parcon.py</a><ul>
<li><a class="reference internal" href="#class-alpha">Class Alpha</a></li>
<li><a class="reference internal" href="#class-alphanum">Class Alphanum</a></li>
<li><a class="reference internal" href="#class-and">Class And</a></li>
<li><a class="reference internal" href="#class-anycase">Class AnyCase</a></li>
<li><a class="reference internal" href="#class-anychar">Class AnyChar</a></li>
<li><a class="reference internal" href="#class-bind">Class Bind</a></li>
<li><a class="reference internal" href="#class-charin">Class CharIn</a></li>
<li><a class="reference internal" href="#class-charnotin">Class CharNotIn</a></li>
<li><a class="reference internal" href="#class-chars">Class Chars</a></li>
<li><a class="reference internal" href="#class-description">Class Description</a></li>
<li><a class="reference internal" href="#class-digit">Class Digit</a></li>
<li><a class="reference internal" href="#class-discard">Class Discard</a></li>
<li><a class="reference internal" href="#class-eanychar">Class EAnyChar</a></li>
<li><a class="reference internal" href="#class-eanycharin">Class EAnyCharIn</a></li>
<li><a class="reference internal" href="#class-eanycharnotin">Class EAnyCharNotIn</a></li>
<li><a class="reference internal" href="#class-ecustomexpectation">Class ECustomExpectation</a></li>
<li><a class="reference internal" href="#class-eregex">Class ERegex</a></li>
<li><a class="reference internal" href="#class-estringliteral">Class EStringLiteral</a></li>
<li><a class="reference internal" href="#class-eunsatisfiable">Class EUnsatisfiable</a></li>
<li><a class="reference internal" href="#class-end">Class End</a></li>
<li><a class="reference internal" href="#class-exact">Class Exact</a></li>
<li><a class="reference internal" href="#class-except">Class Except</a></li>
<li><a class="reference internal" href="#class-expectation">Class Expectation</a></li>
<li><a class="reference internal" href="#class-expected">Class Expected</a></li>
<li><a class="reference internal" href="#class-first">Class First</a></li>
<li><a class="reference internal" href="#class-forward">Class Forward</a></li>
<li><a class="reference internal" href="#class-infixexpr">Class InfixExpr</a></li>
<li><a class="reference internal" href="#class-invalid">Class Invalid</a></li>
<li><a class="reference internal" href="#class-keyword">Class Keyword</a></li>
<li><a class="reference internal" href="#class-limit">Class Limit</a></li>
<li><a class="reference internal" href="#class-literal">Class Literal</a></li>
<li><a class="reference internal" href="#class-longest">Class Longest</a></li>
<li><a class="reference internal" href="#class-lower">Class Lower</a></li>
<li><a class="reference internal" href="#class-name">Class Name</a></li>
<li><a class="reference internal" href="#class-not">Class Not</a></li>
<li><a class="reference internal" href="#class-oneormore">Class OneOrMore</a></li>
<li><a class="reference internal" href="#class-optional">Class Optional</a></li>
<li><a class="reference internal" href="#class-pair">Class Pair</a></li>
<li><a class="reference internal" href="#class-parseexception">Class ParseException</a></li>
<li><a class="reference internal" href="#class-parser">Class Parser</a></li>
<li><a class="reference internal" href="#class-present">Class Present</a></li>
<li><a class="reference internal" href="#class-preserve">Class Preserve</a></li>
<li><a class="reference internal" href="#class-regex">Class Regex</a></li>
<li><a class="reference internal" href="#class-repeat">Class Repeat</a></li>
<li><a class="reference internal" href="#class-result">Class Result</a></li>
<li><a class="reference internal" href="#class-return">Class Return</a></li>
<li><a class="reference internal" href="#class-significantliteral">Class SignificantLiteral</a></li>
<li><a class="reference internal" href="#class-tag">Class Tag</a></li>
<li><a class="reference internal" href="#class-then">Class Then</a></li>
<li><a class="reference internal" href="#class-translate">Class Translate</a></li>
<li><a class="reference internal" href="#class-upper">Class Upper</a></li>
<li><a class="reference internal" href="#class-whitespace">Class Whitespace</a></li>
<li><a class="reference internal" href="#class-word">Class Word</a></li>
<li><a class="reference internal" href="#class-zeroormore">Class ZeroOrMore</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="fileutils.html"
                        title="previous chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">fileutils</span></tt> &#8212; An object-oriented file access library for Python.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="stm.html"
                        title="next chapter"><tt class="docutils literal"><span class="pre">stm</span></tt> &#8212; A pure-Python software transactional memory system.</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/parcon.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="stm.html" title="stm — A pure-Python software transactional memory system."
             >next</a> |</li>
        <li class="right" >
          <a href="fileutils.html" title="fileutils — An object-oriented file access library for Python."
             >previous</a> |</li>
        <li><a href="../contents.html">Test Project  documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright .
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>