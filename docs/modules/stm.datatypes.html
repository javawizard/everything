

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>stm.datatypes — Some useful data types built on top of the STM system. &mdash; Test Project  documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Test Project  documentation" href="../index.html" />
    <link rel="next" title="stm.eventloop —" href="stm.eventloop.html" />
    <link rel="prev" title="stm — A pure-Python software transactional memory system." href="stm.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="stm.eventloop.html" title="stm.eventloop —"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="stm.html" title="stm — A pure-Python software transactional memory system."
             accesskey="P">previous</a> |</li>
        <li><a href="../contents.html">Test Project  documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-stm.datatypes">
<span id="stm-datatypes-some-useful-data-types-built-on-top-of-the-stm-system"></span><h1><a class="reference internal" href="#module-stm.datatypes" title="stm.datatypes: Some useful data types built on top of the STM system."><tt class="xref py py-mod docutils literal"><span class="pre">stm.datatypes</span></tt></a> &#8212; Some useful data types built on top of the STM system.<a class="headerlink" href="#module-stm.datatypes" title="Permalink to this headline">¶</a></h1>
<p>This module provides several transactional data types built on top of the
primitives provided by the STM module.</p>
<div class="section" id="class-broadcastendpoint">
<h2>Class BroadcastEndpoint<a class="headerlink" href="#class-broadcastendpoint" title="Permalink to this headline">¶</a></h2>
<p>A broadcast endpoint from which items can be read.</p>
<p>This class should not be directly instantiated; instead, a BroadcastQueue
instance&#8217;s new_endpoint() method should be called to obtain an endpoint
that reads from the queue in question.</p>
<dl class="class">
<dt id="stm.datatypes.BroadcastEndpoint">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">BroadcastEndpoint</tt><big>(</big><em>self</em>, <em>var</em><big>)</big><a class="headerlink" href="#stm.datatypes.BroadcastEndpoint" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="stm.datatypes.BroadcastEndpoint.duplicate">
<tt class="descname">duplicate</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.BroadcastEndpoint.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and returns a new endpoint containing exactly the same items as
this endpoint. Items inserted into the BroadcastQueue from which this
endpoint was created will be available on both this and the newly
created endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.BroadcastEndpoint.get">
<tt class="descname">get</tt><big>(</big><em>self</em>, <em>block=True</em>, <em>timeout=None</em><big>)</big><a class="headerlink" href="#stm.datatypes.BroadcastEndpoint.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes and returns the next available item from this endpoint.</p>
<p>If block is False and there aren&#8217;t any items currently available on
this endpoint, Empty will be raised. If block is True, this function
retries. If timeout is specified and there still aren&#8217;t any items
available on this endpoint after that many seconds, Timeout will be
raised.</p>
</dd></dl>

<dl class="attribute">
<dt id="stm.datatypes.BroadcastEndpoint.is_empty">
<tt class="descname">is_empty</tt><a class="headerlink" href="#stm.datatypes.BroadcastEndpoint.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this endpoint has no items available (i.e. a call to get()
would retry), False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.BroadcastEndpoint.peek">
<tt class="descname">peek</tt><big>(</big><em>self</em>, <em>block=False</em>, <em>timeout=None</em><big>)</big><a class="headerlink" href="#stm.datatypes.BroadcastEndpoint.peek" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the next available item from this endpoint without removing it.</p>
<p>The block and timeout parameters have the same effect as they do when
passed to self.get(), but block defaults to False (which seems to be
the more common use case when calling peek()).</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.BroadcastEndpoint.replace">
<tt class="descname">replace</tt><big>(</big><em>self</em>, <em>value</em><big>)</big><a class="headerlink" href="#stm.datatypes.BroadcastEndpoint.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Pushes the specified value back onto this endpoint, such that the next
call to get() will return the specified value.</p>
<p>This is used internally to implement peek() and is_empty: an item is
retrieved from the endpoint and then immediately pushed back onto the
endpoint with replace(), thus leaving the endpoint unmodified. It can
also be used externally as needed.</p>
<p>This can be called multiple times to push multiple items onto an
endpoint in LIFO order.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-broadcastqueue">
<h2>Class BroadcastQueue<a class="headerlink" href="#class-broadcastqueue" title="Permalink to this headline">¶</a></h2>
<p>A single-producer, multiple-consumer queue that can have multiple endpoints
from which items can be consumed.</p>
<p>Endpoints are created by calling new_endpoint(). Each endpoint initially
starts out empty; items become available as soon as the creating queue&#8217;s
put() function is called.</p>
<p>Items inserted into the queue with put() become available on all endpoints
to consume. This allows BroadcastQueues to be used to broadcast values to
several different consumers.</p>
<p>When an endpoint is no longer needed, it can be simply discarded. Endpoints
hold a reference to the queue they were created from, not the other way
around, so they will be immediately garbage collected and any items unread
by the endpoint but not by any other endpoint immediately reclaimed.</p>
<p>An interesting side effect of this is that adding items to a queue that has
never had any endpoints created from it, or one that has had all of its
endpoints discarded, silently discards the items added to it, and is thus
a no-op.</p>
<dl class="class">
<dt id="stm.datatypes.BroadcastQueue">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">BroadcastQueue</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.BroadcastQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new, empty broadcast queue.</p>
<dl class="method">
<dt id="stm.datatypes.BroadcastQueue.new_endpoint">
<tt class="descname">new_endpoint</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.BroadcastQueue.new_endpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new BroadcastEndpoint that receives values added to this
queue. The endpoint initially starts out empty; items will appear on it
as soon as put() is called next.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.BroadcastQueue.put">
<tt class="descname">put</tt><big>(</big><em>self</em>, <em>value</em><big>)</big><a class="headerlink" href="#stm.datatypes.BroadcastQueue.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts an item into this queue. The item will then become available on
all endpoints created from it.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-empty">
<h2>Class Empty<a class="headerlink" href="#class-empty" title="Permalink to this headline">¶</a></h2>
<p>Exception thrown from BroadcastEndpoint.get() when block=False is passed
in and no items are currently available.</p>
<dl class="class">
<dt id="stm.datatypes.Empty">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">Empty</tt><a class="headerlink" href="#stm.datatypes.Empty" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</div>
<div class="section" id="class-full">
<h2>Class Full<a class="headerlink" href="#class-full" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="stm.datatypes.Full">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">Full</tt><a class="headerlink" href="#stm.datatypes.Full" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

</div>
<div class="section" id="class-tdict">
<h2>Class TDict<a class="headerlink" href="#class-tdict" title="Permalink to this headline">¶</a></h2>
<p>UPDATE: This now uses 2-3 finger trees. Update accordingly.</p>
<p>A transactional dictionary.</p>
<p>Internally, transactional dicts are maintained with a single TVar holding a
copy-on-write binary tree annotated with dict keys. Insertion (and
appending), removal, and lookup are therefore all O(log n) operations.
len() is O(1), as is iter(), iterkeys(), iteritems(), and itervalues().</p>
<p>One nice property of using a copy-on-write binary tree is iteration: the
iterator returned from iter(tdict) is a snapshot of the dict&#8217;s keys at that
point in time. The dict can therefore be safely modified during iteration,
without affecting the keys produced by the iteration. The same is, of
course, true of iterkeys, iteritems, and itervalues.</p>
<p>All of TDict&#8217;s functions must be called within an STM transaction, with the
exception of __str__/__repr__, which, for the sake of convenience,
wrap themselves in a call to stm.atomically() internally.</p>
<dl class="class">
<dt id="stm.datatypes.TDict">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">TDict</tt><big>(</big><em>self</em>, <em>initial_values=None</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="stm.datatypes.TDict.clear">
<tt class="descname">clear</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>D.clear() -&gt; None.  Remove all items from D.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.get">
<tt class="descname">get</tt><big>(</big><em>self</em>, <em>key</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.get" title="Permalink to this definition">¶</a></dt>
<dd><p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.items">
<tt class="descname">items</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.iteritems">
<tt class="descname">iteritems</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.iteritems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.iterkeys">
<tt class="descname">iterkeys</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.iterkeys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.itervalues">
<tt class="descname">itervalues</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.itervalues" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.keys">
<tt class="descname">keys</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.pop">
<tt class="descname">pop</tt><big>(</big><em>self</em>, <em>key</em>, <em>default=&lt;object object at 0x7fa882c51040&gt;</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.popitem">
<tt class="descname">popitem</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.popitem" title="Permalink to this definition">¶</a></dt>
<dd><p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair
as a 2-tuple; but raise KeyError if D is empty.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.setdefault">
<tt class="descname">setdefault</tt><big>(</big><em>self</em>, <em>key</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.setdefault" title="Permalink to this definition">¶</a></dt>
<dd><p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.update">
<tt class="descname">update</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.update" title="Permalink to this definition">¶</a></dt>
<dd><p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TDict.values">
<tt class="descname">values</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TDict.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="class-tlist">
<h2>Class TList<a class="headerlink" href="#class-tlist" title="Permalink to this headline">¶</a></h2>
<p>A transactional list.</p>
<p>Internally, transactional lists are maintained with a single TVar holding a
reference to a copy-on-write functional 2-3 finger tree (see the
afn.ttftree module) using afn.ttftree.MEASURE_ITEM_COUNT as its measure.
They thus give rise to some rather good performance characteristics:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Time complexity:</th>
<th class="head">Operations that run using this time complexity:</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>amortized O(1)</td>
<td><p class="first">Inserting, removing, or looking up an item at
either end of the list, e.g.:</p>
<blockquote class="last">
<div><ul class="simple">
<li>self.append(some_value)</li>
<li>self.pop()</li>
<li>self.insert(0, some_value)</li>
<li>some_value = list[0]</li>
<li>some_value = list[-1]</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>O(1)</td>
<td><p class="first">len(self)</p>
<p class="last">iter(self) (but note that calling the returned
iterator&#8217;s next() method is amortized O(1))</p>
</td>
</tr>
<tr class="row-even"><td>O(log n)</td>
<td><p class="first">Inserting, removing, or looking up an item by an
arbitrary index, e.g.:</p>
<blockquote class="last">
<div><ul class="simple">
<li>insert(n, some_value)</li>
<li>some_value = list[n]</li>
<li>list[n] = some_value</li>
<li>del list[n], etc.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>O(log min(m, n))
where m and n
are the sizes of
the two lists
involved</td>
<td><p class="first">Concatenating two lists, e.g.:</p>
<blockquote class="last">
<div><ul class="simple">
<li>list1 + list2</li>
<li>list1.extend(list2)</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>O(log r) where r
is the size of
the returned
list</td>
<td><p class="first">Slicing a list, e.g.:</p>
<blockquote class="last">
<div><ul class="simple">
<li>list[m:n]</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>One nice property of using a copy-on-write tree is iteration: the iterator
returned from iter(tlist) is a snapshot of the list at that point in time.
The list can therefore be safely modified during iteration without
affecting the items produced by the iteration.</p>
<p>All of TList&#8217;s functions must be called within an STM transaction, with the
exception of __str__/__repr__, which, for the sake of convenience,
wrap themselves in a call to stm.atomically() internally.</p>
<dl class="class">
<dt id="stm.datatypes.TList">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">TList</tt><big>(</big><em>self</em>, <em>initial_values=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#stm.datatypes.TList" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="stm.datatypes.TList.append">
<tt class="descname">append</tt><big>(</big><em>self</em>, <em>value</em><big>)</big><a class="headerlink" href="#stm.datatypes.TList.append" title="Permalink to this definition">¶</a></dt>
<dd><p>S.append(object) &#8211; append object to the end of the sequence</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TList.count">
<tt class="descname">count</tt><big>(</big><em>self</em>, <em>value</em><big>)</big><a class="headerlink" href="#stm.datatypes.TList.count" title="Permalink to this definition">¶</a></dt>
<dd><p>S.count(value) -&gt; integer &#8211; return number of occurrences of value</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TList.extend">
<tt class="descname">extend</tt><big>(</big><em>self</em>, <em>values</em><big>)</big><a class="headerlink" href="#stm.datatypes.TList.extend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="stm.datatypes.TList.index">
<tt class="descname">index</tt><big>(</big><em>self</em>, <em>value</em><big>)</big><a class="headerlink" href="#stm.datatypes.TList.index" title="Permalink to this definition">¶</a></dt>
<dd><p>S.index(value) -&gt; integer &#8211; return first index of value.
Raises ValueError if the value is not present.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TList.insert">
<tt class="descname">insert</tt><big>(</big><em>self</em>, <em>index</em>, <em>value</em><big>)</big><a class="headerlink" href="#stm.datatypes.TList.insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="stm.datatypes.TList.pop">
<tt class="descname">pop</tt><big>(</big><em>self</em>, <em>index=-1</em><big>)</big><a class="headerlink" href="#stm.datatypes.TList.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>S.pop([index]) -&gt; item &#8211; remove and return item at index (default last).
Raise IndexError if list is empty or index is out of range.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TList.remove">
<tt class="descname">remove</tt><big>(</big><em>self</em>, <em>value</em><big>)</big><a class="headerlink" href="#stm.datatypes.TList.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>S.remove(value) &#8211; remove first occurrence of value.
Raise ValueError if the value is not present.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TList.reverse">
<tt class="descname">reverse</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TList.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>S.reverse() &#8211; reverse <em>IN PLACE</em></p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-tmutableweakref">
<h2>Class TMutableWeakRef<a class="headerlink" href="#class-tmutableweakref" title="Permalink to this headline">¶</a></h2>
<p>(This class is experimental.)</p>
<p>A transactional mutable weak reference.</p>
<p>This class is a hybrid of stm.TWeakRef and stm.TVar: it holds a weak
reference to its value, but permits its value to be modified as desired.</p>
<p>A function to be called when the value referred to by this TMutableWeakRef
is garbage collected may be specified. This callback will only be called
when the TMutableWeakRef&#8217;s current value is garbage collected; it will not
be called on garbage collection of any of its former values.</p>
<dl class="class">
<dt id="stm.datatypes.TMutableWeakRef">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">TMutableWeakRef</tt><big>(</big><em>self</em>, <em>value</em>, <em>callback=None</em><big>)</big><a class="headerlink" href="#stm.datatypes.TMutableWeakRef" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a TMutableWeakRef with the specified initial value.</p>
<p>Note that, as Python does not permit weak references to None, an
initial non-None value must be specified.</p>
<dl class="method">
<dt id="stm.datatypes.TMutableWeakRef.get">
<tt class="descname">get</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TMutableWeakRef.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="stm.datatypes.TMutableWeakRef.set">
<tt class="descname">set</tt><big>(</big><em>self</em>, <em>value</em><big>)</big><a class="headerlink" href="#stm.datatypes.TMutableWeakRef.set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="class-tobject">
<h2>Class TObject<a class="headerlink" href="#class-tobject" title="Permalink to this headline">¶</a></h2>
<p>An abstract class that causes all of its subclass&#8217;s attributes to be backed
by a TDict. This results in the subclass&#8217;s attributes being transactional,
so that they can be modified during a transaction without having to
explicitly wrap all of them with TVars.</p>
<dl class="class">
<dt id="stm.datatypes.TObject">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">TObject</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TObject" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="class-tset">
<h2>Class TSet<a class="headerlink" href="#class-tset" title="Permalink to this headline">¶</a></h2>
<p>A transactional mutable set.</p>
<p>Right now, this actually just uses an underlying Python set which it copies
on every write, so it&#8217;s woefully inefficient. I&#8217;ll be changing it to use
the AVL trees that TList and TDict use soon, but I need to figure out how
to properly implement weak sets in terms of them first. (I could always
just have weak nodes pointing to dereferenced objects collected only during
iteration, but then the iterators can&#8217;t be completely isolated from the set
itself, so that needs some thought.)</p>
<dl class="class">
<dt id="stm.datatypes.TSet">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">TSet</tt><big>(</big><em>self</em>, <em>initial_items=set([])</em>, <em>backing_type=&lt;type 'set'&gt;</em><big>)</big><a class="headerlink" href="#stm.datatypes.TSet" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="stm.datatypes.TSet.add">
<tt class="descname">add</tt><big>(</big><em>self</em>, <em>item</em><big>)</big><a class="headerlink" href="#stm.datatypes.TSet.add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="stm.datatypes.TSet.clear">
<tt class="descname">clear</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TSet.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>This is slow (creates N new iterators!) but effective.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TSet.discard">
<tt class="descname">discard</tt><big>(</big><em>self</em>, <em>item</em><big>)</big><a class="headerlink" href="#stm.datatypes.TSet.discard" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="stm.datatypes.TSet.isdisjoint">
<tt class="descname">isdisjoint</tt><big>(</big><em>self</em>, <em>other</em><big>)</big><a class="headerlink" href="#stm.datatypes.TSet.isdisjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if two sets have a null intersection.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TSet.pop">
<tt class="descname">pop</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#stm.datatypes.TSet.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the popped value.  Raise KeyError if empty.</p>
</dd></dl>

<dl class="method">
<dt id="stm.datatypes.TSet.remove">
<tt class="descname">remove</tt><big>(</big><em>self</em>, <em>value</em><big>)</big><a class="headerlink" href="#stm.datatypes.TSet.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an element. If not a member, raise a KeyError.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-broadcastitem">
<h2>Class _BroadcastItem<a class="headerlink" href="#class-broadcastitem" title="Permalink to this headline">¶</a></h2>
<p>_BroadcastItem(value, next)</p>
<dl class="class">
<dt id="stm.datatypes._BroadcastItem">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">_BroadcastItem</tt><a class="headerlink" href="#stm.datatypes._BroadcastItem" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="attribute">
<dt id="stm.datatypes._BroadcastItem.next">
<tt class="descname">next</tt><a class="headerlink" href="#stm.datatypes._BroadcastItem.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="stm.datatypes._BroadcastItem.value">
<tt class="descname">value</tt><a class="headerlink" href="#stm.datatypes._BroadcastItem.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-dictannotation">
<h2>Class _DictAnnotation<a class="headerlink" href="#class-dictannotation" title="Permalink to this headline">¶</a></h2>
<p>_DictAnnotation(index, key)</p>
<dl class="class">
<dt id="stm.datatypes._DictAnnotation">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">_DictAnnotation</tt><a class="headerlink" href="#stm.datatypes._DictAnnotation" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="attribute">
<dt id="stm.datatypes._DictAnnotation.index">
<tt class="descname">index</tt><a class="headerlink" href="#stm.datatypes._DictAnnotation.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="stm.datatypes._DictAnnotation.key">
<tt class="descname">key</tt><a class="headerlink" href="#stm.datatypes._DictAnnotation.key" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="class-dictentry">
<h2>Class _DictEntry<a class="headerlink" href="#class-dictentry" title="Permalink to this headline">¶</a></h2>
<p>_DictEntry(key, value)</p>
<dl class="class">
<dt id="stm.datatypes._DictEntry">
<em class="property">class </em><tt class="descclassname">stm.datatypes.</tt><tt class="descname">_DictEntry</tt><a class="headerlink" href="#stm.datatypes._DictEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
<dl class="attribute">
<dt id="stm.datatypes._DictEntry.key">
<tt class="descname">key</tt><a class="headerlink" href="#stm.datatypes._DictEntry.key" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="stm.datatypes._DictEntry.value">
<tt class="descname">value</tt><a class="headerlink" href="#stm.datatypes._DictEntry.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">stm.datatypes</span></tt> &#8212; Some useful data types built on top of the STM system.</a><ul>
<li><a class="reference internal" href="#class-broadcastendpoint">Class BroadcastEndpoint</a></li>
<li><a class="reference internal" href="#class-broadcastqueue">Class BroadcastQueue</a></li>
<li><a class="reference internal" href="#class-empty">Class Empty</a></li>
<li><a class="reference internal" href="#class-full">Class Full</a></li>
<li><a class="reference internal" href="#class-tdict">Class TDict</a></li>
<li><a class="reference internal" href="#class-tlist">Class TList</a></li>
<li><a class="reference internal" href="#class-tmutableweakref">Class TMutableWeakRef</a></li>
<li><a class="reference internal" href="#class-tobject">Class TObject</a></li>
<li><a class="reference internal" href="#class-tset">Class TSet</a></li>
<li><a class="reference internal" href="#class-broadcastitem">Class _BroadcastItem</a></li>
<li><a class="reference internal" href="#class-dictannotation">Class _DictAnnotation</a></li>
<li><a class="reference internal" href="#class-dictentry">Class _DictEntry</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="stm.html"
                        title="previous chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">stm</span></tt> &#8212; A pure-Python software transactional memory system.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="stm.eventloop.html"
                        title="next chapter"><tt class="docutils literal"><span class="pre">stm.eventloop</span></tt> &#8212;</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/stm.datatypes.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="stm.eventloop.html" title="stm.eventloop —"
             >next</a> |</li>
        <li class="right" >
          <a href="stm.html" title="stm — A pure-Python software transactional memory system."
             >previous</a> |</li>
        <li><a href="../contents.html">Test Project  documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright .
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>