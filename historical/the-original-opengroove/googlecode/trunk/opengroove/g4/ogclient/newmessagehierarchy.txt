Message hierarchy objects are non-abstract. They are created as they currently are, but instead of overriding a method to receive message info from the hierarchy, you register MessageHierarchyListeners. This is an interface that contains methods for each message hierarchy event that can occur. MessageHierarchyAdapter is a class that implements MessageHierarchyListener, and provides implementations for all of those methods. Those implementations do nothing. That way, if a listener only needs to use one of those methods, then it can subclass MessageHierarchyAdapter and override only the method it needs to.

A message hierarchy has methods for listing all of the inbound messages that are available to it but that it hasn't deleted yet. It can get those by calling listInboundMessages. It can delete an inbound message by calling deleteInboundMessage.

A message hierarchy has methods for listing all of the outbound messages that it has created but has not yet sent. These can be retrieved by calling listOutboundMessages. An outbound message that has not yet been sent (sent messages will not appear in the list returned from listOutboudMessages) can be deleted by calling deleteOutboundMessage. 

Messages returned from these methods are instances of the class Message. These get converted to InboundMessage and OutboundMessage objects when creating and deleting them.

To send a message, a new Message object is created. It's recipient list is set up, along with any properties it needs. A file is then created (DataUtils.createTempFile() can be used to create a temporary file, and has an advantage over File.createTempFile() in that the latter occasionally throws an IOException due to http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6325169 but the former has a workaround to this problem), and the message's contents are written to this file. Then, sendMessage is called, passing in the Message object. Internally, a new OutboundMessage is created and the message's data and file contents are copied to that outbound message, and the outbound message is sent. If the method call gets interrupted before the outbound message object is sent, then it will still end up persisting (due to how the message manager works), but it will be deleted when the message manager is next set up.

Receiving a message works in a similar manner. The message is made available to listInboundMessage calls, and then the message is propegated down through the hierarchy, with listener methods being called as needed.

Because Message objects don't track message ids, a new Message object will be created for each message when a list of messages is retrieved. Message objects support the equals and hashCode methods, but these are based on the message's sender, recipients, properties, and storage file. This will suffice to differentiate between messages returned from hierarchy methods that return lists of messages. This will also suffice to compare messages returned from those lists with ones passed in to listener methods.