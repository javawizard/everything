<p align="center"><font size="5">*XSM: An XML Programming Language*</font></p>

------

<font color="#00aa00" size="3"><b>To run XSM programs online using a Javascript interpreter I wrote, go [http://trivergia.com/xsm/org.opengroove.xsm.web.XSM_web/XSM_web.html here].</b></font>

=Description=
XSM is a programming language that uses XML to represent programs. It's probably one of the most pointless projects I've started, but I need a small server-side scripting language for !OpenGroove's help pages, and this fits the bill for the moment.

------

<wiki:toc max_depth="4"/>

------

=The language=
The language is kind of a cross between Java, Javascript, and Logo (a variant of Lisp). I program in all three, so I've gotten ideas from them. The language shares javascript's and logo's dynamic typing (IE a variable does not have a type; its type is the type of whatever it's holding at the moment), and it shares java's and javascript's autolocal variables (IE you can't see a variable declared in a method that's calling yours). It does not support classes; it is therefore a procedural language. Functions are not first-class objects. Code can be run outside of a function. Code that returns that is run in a context where output is not expected has the output silently discarded.

All tags, except the literal tags, must contain only other XML tags, not plain text. For functions that accept some sort of text as an argument, the text should be wrapped with a string tag.

==Functions==
Functions are defined using the function tag. It has one attribute, name, which is the name of the function.

Functions are called by using the name of the function as a tag name. Tag attribute values are available within the function as variables named "param.NAME", where NAME is the lowercase name of the attribute. Each element within the function call's tag that returns a value is available as an "arg.N" variable, where N is the number starting at 1.

For example, the code:
{{{
<function name="test">
    <print><var name="param.somevalue"></print>
    <print><var name="arg.1"></print>
    <print><var name="arg.2"></print>
</function>
<test somevalue="an attribute">
    <string>a value</string>
    <number>12345</number>
</test>
}}}
Prints the following output:
{{{
an attribute
a value
12345
}}}

==Variadic functions (varargs)==
Since functions don't explicitly specify what attributes and arguments they take when they are defined, any old function can be variadic, both in terms of attributes and in terms of arguments. It's up to the function to decide how it handles both cases. See the `<defined>` function (lower on in the page, at the list of built-in commands) for more information on how to get the number of arguments that were given to the function.

==Code/Argument/Literal functions==
Functions are divided into three different types. User-defined functions are always argument functions.

 * *Code functions* are those that are invoked with their tag content being XSM code. They then do something with it. Tags within a code function don't always have to return something for the code function to use. The function tag itself is a code function. Other examples include `if` and `while`. 

 * *Argument functions* are those that are invoked with their tag content being a list of values. These functions then do stuff with the values, not with the code. All tags within an argument function must return a value (but they are allowed to return null as their value). Functions _defined_ with the function tag are argument functions. Other examples include `set` and `print`.

 * *Literal functions* are those that take raw text as arguments. These might allow tags to be embedded within them, but they do their own special processing on the tags. Examples of literal functions include `string` and `number`.

==Variables==
Variables are dynamically-typed. XSM is a procedural language; there is no such thing as objects in XSM. Variables, therefore, hold one of these types of value:

|| *Literal tag name* || Description ||
|| boolean || A value that is either true or false. ||
|| number  || An signed, 64-bit integer. ||
|| double  || A signed, 64-bit decimal number. ||
|| string  || A piece of text. ||
|| list    || A list of other values. Lists themselves are passed around by reference, so passing a list to a function that modifies the list's content will result in the list being modified in the caller. The literal list tag is an argument function instead of a literal function, and makes a list of each value within it. ||
|| null    || Nothing. ||

Each of the literal tags can be used, with the tag's content being the value to use (which is specific to the type). Additionally, the tags true and false can be used directly in place of `<boolean>true</boolean>` and `<boolean>false</boolean>`, respectively. The string literal can have other tags embedded within it, amid text, and their return value will be embedded in the string.

To create a variable, you use the set tag. This can be invoked with the name attribute and one argument, or two arguments. In the latter case, the first argument is taken as the name of the variable.

To get a variable's value, you use the var tag. It takes either an attribute called name or a single argument, which is used as the name.

For example, the code:
{{{
<set name="foo">
    <string>Hello, how are you?</string>
</set>
<set>
    <string>bar</string>
    <string>I am fine</string>
</set>
<print>
    <var>
        <string>foo</string>
    </var>
</print>
<print>
    <var name="bar"/>
</print>
}}}
Prints the following output:
{{{
Hello, how are you?
I am fine
}}}

==Looping==
Looping is done with the while tag and the for tag. These are code functions that execute their content multiple times.

===While===
While takes an attribute called var. This should be the name of a variable that holds a boolean. The content of the while loop generally modifies this variable as it needs to. When the variable's value is false, the while loop stops looping.

The first child tag can be a condition tag, which contains the condition. In this case, var should not be present as an attribute.

For example, the code:
{{{
<set name="condition">
    <true/>
</set>
<set name="loop">
    <number>3</number>
</set>
<while var="condition">
    <print>
        <string>The number is <var name="loop"/></string>
    </print>
    <set name="loop">
        <add>
            <var name="loop"/>
            <number>1</number>
        </add>
    </set>
    <set name="condition">
        <less>
            <var name="loop"/>
            <number>7</number>
        </less>
    </set>
</while>
}}}
Prints the following output:
{{{
The number is 3
The number is 4
The number is 5
The number is 6
}}}

===For===
The for loop takes the attributes var, initial, final, and step. If any of these (except for var) need to be dynamic, there can be a tag named that whose value is the value to use. These must appear right at the top of the for loop.

===Each===
The each loop is like the for loop, but it iterates over the elements of a list. The list should not be modified during iteration; if it is, the results are undefined. OpenGroove's interpreter throws a ConcurrentModificationException if the list is modified during iteration, except on the last iteration, but this behavior could be different on a different interpreter.

The each loop takes three attributes, any of which can be specified as named tags within the loop instead. They are var, over, and count. Count is optional. Var is the variable that will hold the current element of the list, over is the list (the name of the variable that holds it if it's an attribute), and count is the name of a variable that the current iteration count (starting at 1; all XSM indexes are 1-based) should be stored in.

=Built-in functions=
This is the list of functions that are built in to the XSM language. These do not include !OpenGroove-specific functions. The letter in parentheses immediately after the function name specifies what type of function it is: (a) means an argument function, (c) means a code function, and (l) means a literal function.

Functions that have (todo) after their name are not yet implemented in the interpreter mentioned at the top (the one at the very top, in green text), or are somewhat implemented but are missing features. Functions without (todo) may not yet be in the version of the interpreter that's been uploaded, but they are functioning on my machine and they will be up within a day or two.

If you want to implement any (todo) functions, send me an email (I'm javawiz...@trivergia.com, see the main OpenGroove project page for my full email address)

==Set (a)==
Sets the value of a variable, creating one if one does not already exist. The attribute name specifies the name of the variable to create. The first argument is the value that the variable should have. If the name attribute is not present, then the first argument is the name of the variable to create and the second is the value.

==Var (a)==
Returns the value of the specified variable. The variable is either contained in the attribute name, or it is the single argument to the var function.

==Print (a)==
Prints its single argument. If this program is a standalone program, this will be printed to the console. If this program is embedded inside a web page or an !OpenGroove help page, this will be sent to the page itself. If an attribute called newline has the value "false", then a newline will not be appended.

==Prompt (a)==
Prompts the user for some input. In the above interpreter, this uses javascript to ask them for a single line of text via Window.prompt(). One attribute may be specified, message, or there may be a single child element, and this is the message that will be shown to the user. Prompt then returns the user's input, or null if the user chose cancel.

==Boolean (l)==
Returns a boolean that represents the literal value passed to it.

==True (a)==
Returns the boolean true.

==False (a)==
Returns the boolean false.

==Number (l)==
Returns a number that represents the literal number passed to it. The number is a 64-bit signed integer.

==Double (l)==
Returns a double that represents the literal number passed to it. The number is a 64-bit floating-point number.

==Numeric (l)==
Sort of a combination of number and double. It functions exactly as if it were `<number>` when the content does not contain a decimal point, and `<double>` when the content does contain a decimal point (even if the number after it is 0).

==String (l)==
Returns a string representing its string content. Tags that return can be embedded, and the return value will be converted to a string form and included inside the string. Lists are represented as an open bracket and the value of each item in the list, separated by commas, followed by a close bracket.

==List (a)==
Creates a list that contains each argument to the function. The list command can be empty, which creates a list with no items in it.

==Null (a)==
Returns the value null.

==Function (c) (todo)==
Defines a new function. See [#Functions Functions] for more info.

==While (c) (todo)==

==For (c)==

==Each (c)==

==If (c) (todo)==

==Else (c) (todo)==

==Type (a) (todo)==
Takes either one attribute, var, or contains one element. Returns the type, as a string, of the value of the attribute or of the element, which is the same as the element's literal tag name (null included; the type of null is "null").

==Add (a)==

==Subtract (a)==

==Multiply (a)==

==Divide (a)==

==Less (a) (todo)==

==Greater (a) (todo)==

==And (a) (todo)==

==Or (a) (todo)==

==Not (a) (todo)==

==Increment (a) (todo)==
Not implemented yet. The same thing can be done with `<set name="var"><add><var name="var"/><number>1</number></add></set>`

==Decrement (a) (todo)==
Not implemented yet. The same thing can be done with `<set name="var"><subtract><var name="var"/><number>1</number></subtract></set>`

==Size (a) (todo)==

==Copy (a) (todo)==

==Round (a) (todo)==

==Floor (a) (todo)==

==Ceiling (a) (todo)==

==Item (a) (todo)==

==Overwrite (a) (todo)==

==Resize (a) (todo)==

==Defined (a) (todo)==
Takes one attribute, name (var works too), or a single tag within it that returns a string. Returns true if the variable by that name exists, and false if it doesn't. This can be used within a while loop to figure out how many arguments were given to a custom-defined function:
{{{
<function name="print-arg-count">
    <set name="argcount">
        <number>1</number>
    </set>
    <while>
        <condition>
            <defined>
                <replace regex="\s" replacement="">
                    <string>
                        arg.
                        <var name="argcount"/>
                    </string>
                </replace>
            </defined>
        </condition>
        <set name="argcount">
            <add>
                <var name="argcount"/>
                <number>1</number>
            </add>
        </set>
    </while>
    <set name="argcount">
        <subtract>
            <var name="argcount"/>
            <number>1</number>varargs
        </subtract,>
    </set>
    <print>
        <string><var name="argcount"/> arguments were given to this function.</string>
    </print>
</function>
}}}

==Return (a) (todo)==
Returns the return value of its only child tag from the current custom-defined function.

==Replace (a) (todo)==
Replaces text in a string with other text. This takes one of two attributes, regex or target, which define what to replace it with (target means search for an exact string match and regex means search for a regular expression), and replacement, which defines the new replacement. Unlike most other argument functions that allow arguments as child tags, the replace tag requires all of its attributes that are to be dynamic to be enclosed in a tag named after the attribute. This is because otherwise it wouldn't be able to figure out which is which of regex and target. The very last child tag within the replace tag, however, should not be enclosed in another name tag, and should be a tag that returns a string which is the string to search and replace in. That string itself will not be modified; replace will return the new, modified, string.

==Identity (a) (todo)==
Returns the return value of its only child tag. It essentially acts as if it were not there, and were replaced by its child element. This can be used in cases where a particular tag name is treated specially at the top of another tag. For example, if, for some reason, you wanted to include a call to the var function at the top of a for loop, you would have to enclose it in an identity tag to prevent the for loop from interpreting it as the name of the variable to stick the current count in. 

==Gset (a) (todo)==
Sets a global variable. Same as `<gvar>`, but sets a variable instead of getting one. Same syntax as `<set>`.

==Gvar (a) (todo)==
Gets a global variable (one defined with `<set>` while not within a custom function or one defined with `<gset>`). Exactly the same attributes and arguments as `<var>`.

=Examples=

Visit [http://trivergia.com/xsm the online interpreter] for some examples, To the right of that page there are some links which you can use to load some examples into the interpreter. You can then experiment with them and change them, and see what they do.