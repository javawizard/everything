<p align="center"><font size="5">*XSM: XML Scripting Metalanguage*</font></p>

------

=Description=
XSM is a programming language written in XML. The "meta" part of the name reflects that it was initially written to dynamically generate content for Google Code's wiki language. It will be used as the embedded programming language inside !OpenGroove's help pages. The main reason is that the help pages need a small server-side scripting language (JSP is too heavyweight for this one, and I'm not inclined to jump through the hoops required to get it working in an embedded environment without TCP sockets being needed, and I implemented a Logo programming language interpreter in a single night so an XML programming language for which there are already syntax parsers can't be that difficult) that can be used to embed dynamic help content. This language needs to be independent of the help source (be it the opengroove wiki or files within a plugin), and should preferably be a language that will get ignored by Google Code's wiki parser. An XML-based programming language works nicely for this. It can be embedded within `<wiki:comment>` tags so that Google Code will ignore it, but !OpenGroove can know that xsm within a wiki comment should be run instead of ignored.

Then there could be some sort of pattern, maybe like `<wiki:comment><nohelp-start/></wiki:comment>` and then a corresponding nohelp-end pattern, that could appear, and the content between would show up on google code but !OpenGroove would ignore it. This would allow for warnings at the top of pages that indicate that the user is viewing this on the wiki, not !OpenGroove, so dynamic content might be missing.

=The language=
The language is kind of a cross between Java, Javascript, and Logo (a variant of Lisp). I program in all three, so I've gotten ideas from them. The language shares javascript's and logo's dynamic typing (IE a variable does not have a type; its type is the type of whatever it's holding at the moment), and it shares java's and javascript's autolocal variables (IE you can't see a variable declared in a method that's calling yours). It does not support classes; it is therefore a procedural language. Functions are not first-class objects. Code can be run outside of a function. Code that returns that is run in a context where output is not expected has the output silently discarded.

All tags, except the literal tags, must contain only other XML tags, not plain text. For functions that accept some sort of text as an argument, the text should be wrapped with a string tag.

==Functions==
Functions are defined using the function tag. It has one attribute, name, which is the name of the function.

Functions are called by using the name of the function as a tag name. Tag attribute values are available within the function as variables named "param.NAME", where NAME is the name of the attribute. Each element within the function call's tag that returns a value is available as an "arg.N" variable, where N is the number starting at 1.

For example, the code:
{{{
<function name="test">
    <print><var name="param.somevalue"></print>
    <print><var name="arg.1"></print>
    <print><var name="arg.2"></print>
</function>
<test somevalue="an attribute">
    <string>a value</string>
    <number>12345</number>
</test>
}}}
Prints the following output:
{{{
an attribute
a value
12345
}}}

==Code functions vs. Argument functions==
First off, all custom-defined functions (those created by the user with the function tag) are argument functions.

Code functions are those that are invoked with their tag content being XSM code. They then do something with it. The function tag itself is a code function. Other examples include `if` and `while`. Argument functions are those that are invoked with their tag content being a list of values. These functions then do stuff with the values, not with the code. Functions _defined_ with the function tag are argument functions. Other examples include `set` and `var`.

==Variables==
Variables are dynamically-typed. XSM is a procedural language; there is no such thing as objects in XSM. Variables, therefore, hold one of these types of value:

|| *Literal tag name* || Description ||
|| boolean || A value that is either true or false. ||
|| number  || An signed, 64-bit integer. ||
|| double  || A signed, 64-bit decimal number. ||
|| string  || A piece of text. ||
|| list    || A list of other values. Lists themselves are passed around by reference, so passing a list to a function that modifies the list's content will result in the list being modified in the caller. The literal list tag is an argument function instead of a literal function, and makes a list of each value within it. ||
|| null    || Nothing. ||

Each of the literal tags can be used, with the tag's content being the value to use (which is specific to the type). Additionally, the tags true and false can be used directly in place of `<boolean>true</boolean>` and `<boolean>false</boolean>`, respectively. The string literal can have other tags embedded within it, amid text, and their return value will be embedded in the string.

To create a variable, you use the set tag. This can be invoked with the name attribute and one argument, or two arguments. In the latter case, the first argument is taken as the name of the variable.

To get a variable's value, you use the var tag. It takes either an attribute called name or a single argument, which is used as the name.

For example, the code:
{{{
<set name="foo">
    <string>Hello, how are you?</string>
</set>
<set>
    <string>bar</string>
    <string>I am fine</string>
</set>
<print>
    <var>
        <string>foo</string>
    </var>
</print>
<print>
    <var name="bar"/>
</print>
}}}
Prints the following output:
{{{
Hello, how are you?
I am fine
}}}

==Looping==
Looping is done with the while tag and the for tag. These are code functions that execute their content multiple times.

===While===
While takes an attribute called var. This should be the name of a variable that holds a boolean. The content of the while loop generally modifies this variable as it needs to. When the variable's value is false, the while loop stops looping.

For example, the code:
{{{
<set name="condition">
    <true/>
</set>
<set name="loop">
    <number>3</number>
</set>
<while var="condition">
    <print>
        <string>The number is <var name="loop"/></string>
    </print>
    <set name="loop">
        <add>
            <var name="loop"/>
            <number>1</number>
        </add>
    </set>
    <set name="condition">
        <less>
            <var name="loop"/>
            <number>7</number>
        </less>
    </set>
</while>
}}}
Prints the following output:
{{{
The number is 3
The number is 4
The number is 5
The number is 6
}}}

===For===
For takes two forms: one that iterates a specified number of times, storing the current iteration count in a variable, and one that iterates over each element in a list.

The iteration for loop takes the attributes var, initial, final, and step. If any of these (except for var) need to be dynamic, there can be a tag named that whose value is the value to use. These must appear right at the top of the for loop.

The list for loop takes either an attribute called over, which is the variable that holds the list to iterate over, or a tag called over, which contains the list to iterate over. The attribute var should also be used, which is the name of the variable that is to hold the element currently being iterated over. An optional attribute, count, specifies the name of a variable that is to hold the number of the current iteration (from 1 to the size of the list).

=Built-in functions=
This is the list of functions that are built in to the XSM language. These do not include !OpenGroove-specific functions.

==Set==

==Var==

==Print==

==Boolean==

==True==

==False==

==Number==

==Double==

==String==

==List==

==Null==

==Function==

==While==

==For==

==If==

==Else==

==Condition==

==Add==

==Subtract==

==Multiply==

==Divide==

==Less==

==Greater==

==And==

==Or==

==Not==

==Increment==

==Decrement==

==Size==

==Copy==

==Round==

==Floor==

==Ceiling==

==Item==

==Overwrite==

==Resize==

=Examples=
{{{
<var name="testvar"><number>1</number></var>
}}}