package net.sf.convergia.client.tools.games.risk;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Polygon;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

import java.util.ArrayList;

/**
 * A program for graphically mapping the boundaries of each country and
 * continent on a risk map.
 * 
 * the properties file that it stores it's data as has a few attributes for each
 * country. those are (NAME is the name of the country): <Br/><br/> NAME-points
 * the list of points for the country, x separated from y by a comma, and each
 * pair separated by 2 commas. for example, 3,7,,4,9,,2,2<br/> NAME-x the x
 * coordinate of the center<br/> NAME-y the y coordinate of the center<br/>
 * NAME-assoc a comma-separated list of associations between this country and
 * others.<br/>
 * 
 * @author Alexander Boyd
 * 
 */
public class RiskMapper
{
	private static Properties properties = new Properties();

	private static RiskBoard board;

	private static int nextX;

	private static int nextY;

	private static Polygon buildingPolygon;

	private static boolean isDrawing = true;

	/**
	 * @param args
	 */
	public static void main(String[] args) throws Throwable
	{
		final JFrame frame = new JFrame("RiskMapper - poly");
		board = new RiskBoard();
		JPanel panel = new JPanel();
		panel.add(board);
		if (new File("plot.properties").exists())
			properties.load(new FileInputStream("plot.properties"));
		board.addMouseListener(new MouseListener()
		{

			public void mouseClicked(MouseEvent e)
			{
				int x = e.getX();
				int y = e.getY();
				if (isDrawing)
				{
					synchronized (RiskMapper.class)
					{
						if (buildingPolygon == null)
							buildingPolygon = new Polygon(new int[0],
									new int[0], 0);
						int[] xs = new int[buildingPolygon.npoints + 1];
						int[] ys = new int[buildingPolygon.npoints + 1];
						System.arraycopy(buildingPolygon.xpoints, 0, xs, 0,
								buildingPolygon.npoints);
						System.arraycopy(buildingPolygon.ypoints, 0, ys, 0,
								buildingPolygon.npoints);
						xs[xs.length - 1] = x;
						ys[ys.length - 1] = y;
						buildingPolygon = new Polygon(xs, ys,
								buildingPolygon.npoints + 1);
						plot();
					}
				} else
				{
					Polygon poly = buildingPolygon;
					buildingPolygon = null;
					// currentPolygon = null;
					String name = JOptionPane.showInputDialog(frame,
							"country name");
					if (name == null)
					{
						isDrawing = true;
						currentPolygon = null;
						plot();
						return;
					}
					String nextAssociation;
					ArrayList<String> associationsAllowed = new ArrayList<String>();
					ArrayList<String> associations = new ArrayList<String>();
					for (Map.Entry entry : properties.entrySet())
					{
						if (entry.getKey().toString().endsWith("-assoc"))
						{
							associationsAllowed.add(entry.getKey().toString()
									.substring(
											0,
											entry.getKey().toString().length()
													- ("-assoc".length())));
						}
					}
					do
					{
						Collections.sort(associationsAllowed);
						nextAssociation = (String) JOptionPane.showInputDialog(
								frame, "associations, cancel to finish", null,
								JOptionPane.PLAIN_MESSAGE, null,
								associationsAllowed.toArray(), null);
						if (nextAssociation != null)
						{
							associations.add(nextAssociation);
							associationsAllowed.remove(nextAssociation);
						}
						plot();
					} while (nextAssociation != null);
					plot();
					properties.setProperty(name + "-assoc", delimited(
							associations, ","));
					properties.setProperty(name + "-x", "" + x);
					properties.setProperty(name + "-y", "" + y);
					ArrayList<String> pointStrings = new ArrayList<String>();
					for (int i = 0; i < poly.npoints; i++)
					{
						pointStrings.add("" + poly.xpoints[i] + ","
								+ poly.ypoints[i]);
					}
					properties.setProperty(name + "-points", delimited(
							pointStrings, ",,"));
					try
					{
						properties
								.store(new FileWriter("plot.properties"),
										"Generated by net.sf.convergia.client.tools.games.risk.RiskMappter");
					} catch (IOException e1)
					{
						// TODO Feb 15, 2008 Auto-generated catch block
						throw new RuntimeException(
								"TODO auto generated on Feb 15, 2008 : "
										+ e1.getClass().getName() + " - "
										+ e1.getMessage(), e1);
					}
					JOptionPane.showMessageDialog(frame, "done");
					isDrawing = true;
					currentPolygon = null;
					plot();
					board.getNextButton().setEnabled(true);
					frame.setTitle("RiskMapper - poly");
				}
			}

			public void mouseEntered(MouseEvent e)
			{
				// TODO Auto-generated method stub

			}

			public void mouseExited(MouseEvent e)
			{
				// TODO Auto-generated method stub

			}

			public void mousePressed(MouseEvent e)
			{
				// TODO Auto-generated method stub

			}

			public void mouseReleased(MouseEvent e)
			{
				// TODO Auto-generated method stub

			}
		});
		board.getNextButton().addActionListener(new ActionListener()
		{

			public void actionPerformed(ActionEvent e)
			{
				synchronized (RiskMapper.class)
				{
					if (buildingPolygon == null || buildingPolygon.npoints < 3)
					{
						JOptionPane.showMessageDialog(frame,
								"need at least 3 points first");
						return;
					}
					board.getNextButton().setEnabled(false);
					isDrawing = false;
					currentPolygon = buildingPolygon;
					plot();
					frame.setTitle("RiskMapper - center");
				}
			}
		});
		board.addMouseMotionListener(new MouseMotionListener()
		{

			public void mouseDragged(MouseEvent e)
			{
				// TODO Auto-generated method stub

			}

			public void mouseMoved(MouseEvent e)
			{
				if (!isDrawing)
					return;
				int x = e.getX();
				int y = e.getY();
				if (buildingPolygon != null)
				{
					synchronized (RiskMapper.class)
					{
						if (buildingPolygon != null)
						{
							int[] xs = new int[buildingPolygon.npoints + 1];
							int[] ys = new int[buildingPolygon.npoints + 1];
							System.arraycopy(buildingPolygon.xpoints, 0, xs, 0,
									buildingPolygon.npoints);
							System.arraycopy(buildingPolygon.ypoints, 0, ys, 0,
									buildingPolygon.npoints);
							xs[xs.length - 1] = x;
							ys[ys.length - 1] = y;
							currentPolygon = new Polygon(xs, ys,
									buildingPolygon.npoints + 1);
							plot();
						}
					}
				}
			}
		});
		frame.getContentPane().add(new JScrollPane(panel));
		frame.pack();
		frame.show();
		plot();
	}

	public static Polygon currentPolygon = null;

	private static void plot()
	{
		board.clearPolygons();
		for (Map.Entry entry : properties.entrySet())
		{
			String key = entry.getKey().toString();
			String value = entry.getValue().toString();
			if (!(key.endsWith("-points")))
				continue;
			String[] pointsString = value.split("\\,\\,");
			int[] xs = new int[pointsString.length];
			int[] ys = new int[pointsString.length];
			for (int i = 0; i < pointsString.length; i++)
			{
				String[] pointComponents = pointsString[i].split("\\,");
				xs[i] = Integer.parseInt(pointComponents[0]);
				ys[i] = Integer.parseInt(pointComponents[1]);
			}
			Polygon polygon = new Polygon(xs, ys, pointsString.length);
			board.addPolygon(polygon, Color.BLUE, false, new BasicStroke(2.0f,
					BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND));
			String assoc = properties.getProperty((key.substring(0, key
					.length()
					- "-points".length()))
					+ "-assoc");
			if (assoc == null)
				assoc = "";
			String[] associations = assoc.split("\\,");
			if (associations[0].length() > 0)
			{
				String txs = properties.getProperty((key.substring(0, key
						.length()
						- "-points".length()))
						+ "-x");
				String tys = properties.getProperty((key.substring(0, key
						.length()
						- "-points".length()))
						+ "-y");
				int tx = Integer.parseInt(txs);
				int ty = Integer.parseInt(tys);
				for (String association : associations)
				{
					String oxs = properties.getProperty(association + "-x");
					String oys = properties.getProperty(association + "-y");
					int ox = Integer.parseInt(oxs);
					int oy = Integer.parseInt(oys);
					board.addPolygon(new Polygon(new int[]
					{ tx, ox }, new int[]
					{ ty, oy }, 2), Color.GREEN, false, new BasicStroke(2.0f,
							BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
				}
			}
		}
		if (currentPolygon != null)
			board.addPolygon(currentPolygon, Color.RED, false, new BasicStroke(
					2.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND));
	}

	/**
	 * returns a string containing each of the items in the list specified,
	 * separated by <code>delimiter</code>. if there are no items, the empty
	 * string is returned. this method is designed to approximately be the
	 * opposite of String.split, except that split uses regex instead of literal
	 * strings.
	 * 
	 * @param items
	 * @param delimiter
	 * @return
	 */
	public static String delimited(List<String> items, String delimiter)
	{
		String s = "";
		for (String i : items)
		{
			if (!s.equals(""))
				s += delimiter;
			s += i;
		}
		return s;
	}

}
