

===========================
:mod:`parcon` --- parcon.py
===========================

.. module:: parcon
   :synopsis: parcon.py

Parcon is a parser library written by Alexander Boyd and James Stoker. It's
designed to be fast, easy to use, and to provide informative error messages.

(and it's designed to include new, awesome things, like syntax diagram
generators.)

Technically, it's a monadic parser combinator library, but you don't need to
know that unless you're doing really fancy things. (The bind and return
operations are provided by the Bind and Return parsers, respectively.) It's
also technically a parser combinator library, but again, you usually won't need
to know that.

Parcon grammars are written as Python statements that make use of various
classes provided with Parcon.

Parcon also supports generation of graphs and generation of syntax diagrams
(also known as railroad diagrams) from parsers. See the parcon.graph and
parcon.railroad modules, respectively, for information on how to generate these
graphs and diagrams.

To get started with Parcon, look at all of the subclasses of Parser, _GParser,
_RParser, and _GRParser, and specifically, their parse_string methods. And
perhaps take a look at this example:

>>> parser = "(" + ZeroOrMore(SignificantLiteral("a") | SignificantLiteral("b")) + ")"
>>> parser.parse_string("(abbaabaab)")
['a', 'b', 'b', 'a', 'a', 'b', 'a', 'a', 'b']
>>> parser.parse_string("(a)")
['a']
>>> parser.parse_string("")
Traceback (most recent call last):
ParseException: Parse failure: At position 0: expected one of "("
>>> parser.parse_string("(a")
Traceback (most recent call last):
ParseException: Parse failure: At position 2: expected one of "a", "b", ")"
>>> parser.parse_string("(ababacababa)")
Traceback (most recent call last):
ParseException: Parse failure: At position 6: expected one of "a", "b", ")"

The Parser class, and hence all of its subclasses, overload a few operators
that can be used to make writing parsers easier. Here's what each operator
ends up translating to:

 * x + y is the same as Then(x, y).
 * x | y is the same as First(x, y).
 * x - y is the same as Except(x, y).
 * x & y is the same as And(x, y).
 * -x is the same as Optional(x).
 * +x is the same as OneOrMore(x).
 * ~x is the same as Discard(x).
 * x[min:max] is the same as Repeat(x, min, max).
 * x[some_int] is the same as Repeat(x, some_int, some_int).
 * x[some_string] is the same as Tag(some_string, x).
 * x[...] (three literal dots) is the same as ZeroOrMore(x).
 * x[function] is the same as Translate(x, function).
 * x(name="test") is the same as Name("test", x).
 * x(desc="test") or x(description="test") is the same as Desc("test", x)
 * "x" op some_parser or some_parser op "x" is the same as Literal("x") op 
   some_parser or some_parser op Literal("x"), respectively.

A simple expression evaluator written using Parcon:

>>> from parcon import number, Forward, InfixExpr
>>> import operator
>>> expr = Forward()
>>> term = number[float] | "(" + expr + ")"
>>> term = InfixExpr(term, [("*", operator.mul), ("/", operator.truediv)])
>>> term = InfixExpr(term, [("+", operator.add), ("-", operator.sub)])
>>> expr << term(name="expr")

Some example expressions that can now be evaluated using the above
simple expression evaluator:

>>> expr.parse_string("1+2")
3.0
>>> expr.parse_string("1+2+3")
6.0
>>> expr.parse_string("1+2+3+4")
10.0
>>> expr.parse_string("3*4")
12.0
>>> expr.parse_string("5+3*4")
17.0
>>> expr.parse_string("(5+3)*4")
32.0
>>> expr.parse_string("10/4")
2.5

A syntax diagram can also be generated for the expression parser with:

>>> expr.draw_productions_to_png({}, "expr-syntax.png")

Another example use of Parcon, this one being a JSON parser (essentially
a reimplementation of Python's json.loads, without all of the fancy
arguments that it supports, and currently without support for backslash
escapes in JSON string literals):

>>> from parcon import *
>>> import operator
>>> cat_dicts = lambda x, y: dict(x.items() + y.items())
>>> json = Forward()
>>> number = (+Digit() + -(SignificantLiteral(".") + +Digit()))[flatten]["".join][float]
>>> boolean = Literal("true")[lambda x: True] | Literal("false")[lambda x: False]
>>> string = ('"' + Exact(ZeroOrMore(AnyChar() - CharIn('\"'))) +  '"')["".join]
>>> null = Literal("null")[lambda x: None]
>>> pair = (string + ":" + json[lambda x: (x,)])[lambda x: {x[0]: x[1]}]
>>> json_object = ("{" + Optional(InfixExpr(pair, [(",", cat_dicts)]), {}) + "}")
>>> json_list = ("[" + Optional(InfixExpr(json[lambda x: [x]], [(",", operator.add)]), []) + "]")
>>> json << (json_object | json_list | string | boolean | null | number)

Thereafter, json.parse_string(text) can be used as a replacement for
Python's json.loads.

An interesting fact: the set of all Parcon parsers form a monoid with the
binary operation being the Then parser (or the + operator, since it produces a
Then parser) and the identity element being Return(None).

-----------
Class Alpha
-----------

Same as CharIn(upper_chars + lower_chars).

.. class:: Alpha(self)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

--------------
Class Alphanum
--------------

Same as CharIn(upper_chars + lower_chars + digit_chars).

.. class:: Alphanum(self)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

---------
Class And
---------

A parser that matches whatever its specified parser matches as long as its
specified check_parser also matches at the same location. This could be
considered the opposite of Except: And matches when the second parser it's
passed also matches, while Except matches when the second parser it's
passed does not match. Wrapping the second parser with Not can make And
behave as Except and vice versa, although using whichever one makes more
sense will likely lead to more informative error messages when parsing
fails.

.. class:: And(self, parser, check_parser)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-------------
Class AnyCase
-------------

A case-insensitive version of Literal. Behaves exactly the same as Literal
does, but without regard to the case of the input.

If enough people request a version that returns the matched text instead of
None (send me an email if you're one of these people; my email is at the
top of this file, in the module docstring), I'll provide such a parser. For
now, though, you can use a Regex parser to accomplish the same thing.

.. class:: AnyCase(self, text)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-------------
Class AnyChar
-------------

A parser that matches any single character. It returns the character that
it matched.

.. class:: AnyChar

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

----------
Class Bind
----------

A parser that functions similar to Then, but that allows the second parser
to be determined from the value that the first parser produced. It's
constructed as Bind(parser, function). parser is the first parser to run.
function is a function that accepts one argument, the value that the first
parser produced. It will be called whenever the first parser succeeds; the
value that the first parser produced will be passed in, and the function
should return a second parser. This parser will then be applied immediately
after where the first parser finished parsing from (similar to how Then
starts its second parser parsing after where its first parser finished).
Bind then returns the value that the second parser produced.

Those of you familiar with functional programming will notice that this
parser implements a monadic bind, hence its name.

.. class:: Bind(self, parser, function)



   .. method:: consume(self, text, position, end)



   .. method:: do_graph(self, graph)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, whitespace)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

------------
Class CharIn
------------

A parser that matches a single character as long as it is in the specified
sequence (which can be a string or a list of one-character strings). It
returns the character matched.

.. class:: CharIn(self, chars)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

---------------
Class CharNotIn
---------------

A parser that matches a single character as long as it is not in the
specified sequence. This is much the opposite of CharIn.

.. class:: CharNotIn(self, chars)



   .. method:: consume(self, text, position, end)



   .. method:: do_graph(self, graph)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-----------
Class Chars
-----------

A parser that parses a specific number of characters and returns them as
a string. Chars(5), for example, would parse exactly five characters in a
row, and return a string of length 5. This would be essentially identical
to AnyChar()[5:5]["".join], except for two things: 1, the whitespace parser
is not applied in between each character parsed by Chars (although it is
applied just before the first character), and 2, Chars is much more
efficient than the aforementioned expression using AnyChar.

This can be used in combination with Bind to create a parser that parses
a binary protocol where a fixed number of bytes are present that specify
the length of the rest of a particular packet, followed by the rest of the
packet itself. For example, imagine a protocol where packets look like this:

length b1 b2 b3 ... blength

a.k.a. a byte indicating the length of the data carried in that packet,
followed by the actual data of the packet. Such a packet could be parsed
into a string containing the data of a single packet with this:

Bind(AnyChar(), lambda x: Chars(ord(x)))

.. class:: Chars(self, number)



   .. method:: consume(self, text, position, end)



   .. method:: do_graph(self, graph)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-----------------
Class Description
-----------------



.. class:: Description(self, description, parser)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-----------
Class Digit
-----------

Same as CharIn(digit_chars).

.. class:: Digit(self)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-------------
Class Discard
-------------

A parser that matches if the parser it's constructed with matches. It
consumes the same amount of input that the specified parser does, but this
parser always returns None as the result. Since instances of Then treat
None values specially, you'll likely use this parser in conjunction with
Then in some grammars.

.. class:: Discard(self, parser)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

--------------
Class EAnyChar
--------------

An expectation indicating that any character was expected.

.. class:: EAnyChar

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. method:: format(self)



----------------
Class EAnyCharIn
----------------

An expectation indicating that any character in a particular sequence of
characters (a list of one-character strings, or a string containing the
expected characters) was expected.

.. class:: EAnyCharIn(self, chars)



   .. method:: format(self)



-------------------
Class EAnyCharNotIn
-------------------

An expectation indicating that any character not in a particular sequence of
characters (a list of one-character strings, or a string containing the
expected characters) was expected.

.. class:: EAnyCharNotIn(self, chars)



   .. method:: format(self)



------------------------
Class ECustomExpectation
------------------------

An expectation indicating that some custom value was expected. This is used
when instances of the Expected parser fail. Users implementing their own
subclass of Parser that don't want to write a corresponding subclass of
Expectation but that find that none of the current subclasses of
Expectation fit their needs might also want to use ECustomExpectation.

.. class:: ECustomExpectation(self, message)



   .. method:: format(self)



------------
Class ERegex
------------

An expectation indicating that some regular expression was expected.

.. class:: ERegex(self, pattern_text)



   .. method:: format(self)



--------------------
Class EStringLiteral
--------------------

An expectation indicating that some literal string was expected. When
formatted, the string will be enclosed in double quotes. In the future, I
may have the representation as returned from Python's repr function be used
instead.

.. class:: EStringLiteral(self, text)



   .. method:: format(self)



--------------------
Class EUnsatisfiable
--------------------

An expectation indicating that there is no input that could have been
present that would have made the parser in question succeed or consume more
input. Invalid(), for example, returns EUnsatisfiable() since nothing will
make an Invalid match, and EStringLiteral, when it succeeds, returns
EUnsatisfiable() since there isn't any additional text that could be added
that would make EStringLiteral consume more of the input.

EUnsatisfiable is treated specially by format_failure; instances of it are
removed if there are expectations of any other type in the list provided
to format_failure. If there are not, the EUnsatisfiable with the greatest
position (expectations are stored as tuples of (position, Expectation)) is
used, and the message will look something like "At position n: expected
EOF".

.. class:: EUnsatisfiable

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. method:: format(self)



---------
Class End
---------

A parser that matches only at the end of input. It parses whitespace before
checking to see if it's at the end, so it will still match even if there is
some whitespace at the end of the input. (If you don't want it to consume
any whitespace, you can use Exact(End()).)

This parser's result is always None. End(True) will consume any whitespace
that it matches while searching for the end, which can improve performance
under certain circumstances by avoiding having to parse out whitespace a
second time. End(False) will still skip over whitespace while searching
for the end, but it won't consume it, which may be desirable if the
whitespace in question is significant to the grammar. End() is the same as
End(True).

Note that this parser succeeds at the end of the /logical/ input given to
it; specifically, if you've restricted the region to parse with Length, End
matches at the end of the limit set by Limit, not at the end of the actual
input. A more technical way to put it would be to say that if, after
removing whitespace, the resulting position is equal to the end parameter
passed to the parse function, then this parser matches. Otherwise, it fails.

.. class:: End(self, consume=True)

   Creates a new End parser. consume is described in the class docstring.

   .. method:: consume(self, text, position, end)



   .. method:: do_graph(self, graph)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-----------
Class Exact
-----------

A parser that returns whatever the specified parser returns, but Invalid()
will be passed as the whitespace parser to the specified parser when its
parse method is called. This allows for sections of the grammar to take
whitespace significantly, which is useful in, for example, string literals.
For example, the following parser, intended to parse string literals,
demonstrates the problem:

>>> stringLiteral = '"' + ZeroOrMore(AnyChar() - '"')["".join] + '"'
>>> stringLiteral.parse_string('"Hello, great big round world"')
'Hello,greatbigroundworld'

This is because the whitespace parser (which defaults to Whitespace())
consumed all of the space in the string literal. This can, however, be
rewritten using Exact to mitigate this problem:

>>> stringLiteral = Exact('"' + ZeroOrMore(AnyChar() - '"')["".join] + '"')
>>> stringLiteral.parse_string('"Hello, great big round world"')
'Hello, great big round world'

This parser produces the correct result, 'Hello, great big round world'.

.. class:: Exact(self, parser, space_parser=Invalid())



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

------------
Class Except
------------

A parser that matches and returns whatever the specified parser matches
and returns, as long as the specified avoid_parser does not also match at
the same location. For example, Except(AnyChar(), Literal("*/")) would
match any character as long as that character was not a * followed
immediately by a / character. This would most likely be useful in, for
example, a parser designed to parse C-style comments.

When this parser is converted to a railroad diagram, it simply replaces
itself with the underlying parser it wraps. The resulting railroad diagram
does not, therefore, mention the avoid parser, so you should be careful
that this is really what you want to do.

.. class:: Except(self, parser, avoid_parser)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-----------------
Class Expectation
-----------------

NOTE: Most users won't need to know about this class or any of its
subclasses. They're usually only used internally by Parcon, but advanced
users may wish to use them.

An expectation. Instances of the various subclasses of this class are
provided as part of a Result object to indicate what could have made a
parser succeed if it failed, or consume more input if it succeeded.
Expectations are used to format the error message when Parser.parse_string
throws an exception because of a parse error.

This class should not be instantiated directly; one of its various
subclasses should be used instead.

.. class:: Expectation

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. method:: format(self)

      Formats this expectation into a human-readable string. For example,
      EStringLiteral("hello").format() returns '"hello"', and
      EAnyCharIn("abc").format() returns 'any char in "abc"'.

      Subclasses must override this method; Expectation's implementation of
      the method raises NotImplementedError.

--------------
Class Expected
--------------

A parser that allows customization of the error message provided when the
parser it's created with fails. For example, let's say that you had a
parser that would parse numbers with decimals, such as 1.5:

>>> decimal = +Digit() + "." + +Digit()

Now let's say that in your grammar, you included "true" and "false" as
things that could be in the same location as a decimal number:

>>> something = decimal | "true" | "false"

If you call something.parse_string("bogus"), the resulting error message
will be:

>>> something.parse_string("bogus")
Traceback (most recent call last):
ParseException: Parse failure: At position 0: expected one of any char in "0123456789", "true", "false"

which isn't very pretty or informative. If, instead, you did this:

>>> decimal = +Digit() + "." + +Digit()
>>> decimal = Expected(decimal, "decimal number")
>>> something = decimal | "true" | "false"

Then the error message would instead be something like:

>>> something.parse_string("bogus")
Traceback (most recent call last):
ParseException: Parse failure: At position 0: expected one of decimal number, "true", "false"

which is more informative as to what's missing.

If the parameter remove_whitespace is True when constructing an instance
of Expected, whitespace will be removed before calling the underlying
parser's parse method. This will usually make error messages more accurate
about the position at which this whole Expected instance was expected.
If it's False, whitespace will not be removed, and it will be up to the
underlying parser to remove it; as a result, error messages will indicate
the position /before/ the removed whitespace as where the error occurred,
which is usually not what you want.

.. class:: Expected(self, parser, expected_message, remove_whitespace=True)



   .. method:: consume(self, text, position, end)



   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-----------
Class First
-----------

A parser that tries all of its specified parsers in order. As soon as one
matches, its result is returned. If none of them match, this parser fails.

The parsers can be specified either as arguments (i.e. First(parser1,
parser2, parser3) or as a single list or tuple (i.e. First([parser1,
parser2, parser3]).

.. class:: First(self, *parsers)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-------------
Class Forward
-------------

A parser that allows forward-definition. In other words, you can create a
Forward and use it in a parser grammar, and then set the parser that it
actually represents later on. This is useful for defining grammars that
need to include themselves (for example, parentheses in a numerical
expression contain yet another numberical expression, which is an example
of where this would be used).

You create a forward with something like this:

forward = Forward()

You can then use it in your grammar as you would a normal parser. When
you're ready to set the parser that the Forward should actually represent,
you can do it either with:

forward << parser

or with:

forward.set(parser)

Both of them cause the forward to act as if it was really just the
specified parser.

The parser must be set before parse is called on anything using the
Forward instance.

You can also specify the parser when you create the Forward instance. This
is usually somewhat pointless, but it can be useful if you're simply trying
to create a mutable parser (the parser can be set into a Forward multiple
times, with the effect of changing the underlying parser each time).

.. class:: Forward(self, parser=None)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

   .. attribute:: railroad_children



   .. method:: set(self, parser)

      Sets the parser that this Forward should use. After you call this
      method, this Forward acts just like it were really the specified parser.

      This method can be called multiple times; each time it's called, it
      changes the parser in use by this Forward instance.

---------------
Class InfixExpr
---------------

A parser that's created with a component parser and a series of operator
parsers, which can be literal strings (and will be translated to Literal
instances), and two-argument functions for each of these operator parsers.
It parses expressions of the form "component" or "component op component"
or "component op component op component" etc. For each op it encounters in
the result it parses, it calls the two-arg function supplied with that
operator, passing in the value of the parser on its left and the value of
the parser on its right. It then stores the result, and moves onto the next
operator, this time using the aforementioned result as the left-hand value
for the next operator.

This reduction of values proceeds from left to right, which makes InfixExpr
implement a left-associative infix grammar. In the future, there will be a
way to specify that certain operators should be right-associative instead.

If only a single component is present, InfixExpr will match that and return
whatever the component resulted in. If not even a single component is
present, InfixExpr will fail to match.

.. class:: InfixExpr(self, component_parser, operators)

   Creates an InfixExpr. component_parser is the parser that will parse
   the individual components of the expression. operators is a list of
   2-tuples; each tuple represents an operator, with the first item in the
   tuple being a parser that parses the operator itself (or a literal
   string, such as "+", "-", etc, which will be wrapped with a Literal
   instance) and the second item being a two-arg function that will be
   used to reduce components on either side of the operator to get a
   result.

   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

   .. attribute:: railroad_children



-------------
Class Invalid
-------------

A parser that never matches any input and always fails.

.. class:: Invalid

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. method:: consume(self, text, position, end)



   .. method:: do_graph(self, graph)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-------------
Class Keyword
-------------

A parser that matches the specified parser as long as it is followed
immediately by the specified terminator parser, or by whitespace
(according to the current whitespace parser) if a terminator parser is not
specified.

If exact_terminator is True, the terminator is matched with Invalid() as
its whitespace parser. This prevents the whitespace parser from consuming
input that the terminator might have been expecting to see to indicate
proper termination of the keyword. If exact_terminator is False, the same
whitespace parser passed to Keyword will be passed into the terminator.

If or_end is True, the terminator will be replaced with
(terminator | End()) just before attempting to parse it, which would allow
the keyword to be present at the end of the input without causing a parse
failure due to the keyword not being followed immediately by the
terminator.

.. class:: Keyword(self, parser, terminator=None, exact_terminator=True, or_end=True)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-----------
Class Limit
-----------

A parser that imposes a limit on how much input its underlying parser can
consume. All parsers, when asked to parse text, are passed the position
that they can parse to before they have to stop; normally this is the length
of the string being passed in. Limit, however, allows this to be set to a
smaller value.

When you construct a Limit instance, you pass in a parser that it will
call and the number of characters that the specified parser can consume.
If there aren't that many characters left in the input string, no limit is
placed on what the specified parser can consume.

You can also pass a parser instead of a number as the limit for how many
characters can be parsed. If you do that, Limit will apply that parser
first, then take its result (which should be an int or a long) and use
that as the limit when applying the main parser.

The behavior of the latter paragraph allows you to write parsers that
parse length-specified values. For example, if you're parsing some sort of
string from a piece of binary data where the string is stored as four
bytes representing the length of the string followed by the bytes of the
string itself, you could do that with
Limit(parcon.binary.integer, ZeroOrMore(AnyChar()))[concat].

.. class:: Limit(self, length, parser)



   .. method:: consume(self, text, position, end)



   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-------------
Class Literal
-------------

A parser that matches the specified literal piece of text. It succeeds
only if that piece of text is found, and it returns None when it succeeds.
If you need the return value to be the literal piece of text, you should
probably use SignificantLiteral instead.

.. class:: Literal(self, text)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-------------
Class Longest
-------------

A parser that tries all of its specified parsers. The longest one that
succeeds is chosen, and its result is returned. If none of the parsers
succeed, Longest fails.

The parsers can be specified either as arguments (i.e. First(parser1,
parser2, parser3) or as a single list or tuple (i.e. First([parser1,
parser2, parser3]).

Longest is typically more expensive than First since it has to try each
parser to see which one consumes the most input whereas First stops trying
parsers once one succeeds. Because of this, it's usually better to use
First if the parsers to check can be reordered so that those consuming the
most input are at the beginning of the list.

.. class:: Longest(self, *parsers)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-----------
Class Lower
-----------

Same as CharIn(lower_chars).

.. class:: Lower(self)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

----------
Class Name
----------



.. class:: Name(self, name, parser)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

---------
Class Not
---------

A parser that matches only if the parser it's created with does not. If the
aforementioned parser fails, then Not succeeds, consuming no input and 
returning None. If the aforementioned parser succeeds, then Not fails.

.. class:: Not(self, parser)



   .. method:: consume(self, text, position, end)



   .. method:: do_graph(self, graph)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

---------------
Class OneOrMore
---------------

Same as ZeroOrMore, but requires that the specified parser match at least
once. If it does not, this parser will fail.

.. class:: OneOrMore(self, parser)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

--------------
Class Optional
--------------

A parser that returns whatever its underlying parser returns, except that
if the specified parser fails, this parser succeeds and returns the default
result specified to it (which, itself, defaults to None).

.. class:: Optional(self, parser, default=None)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

----------
Class Pair
----------

Pair(key, value)

.. class:: Pair

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. attribute:: key

      Alias for field number 0

   .. attribute:: value

      Alias for field number 1

--------------------
Class ParseException
--------------------



.. class:: ParseException(self, message, expectations=None)



------------
Class Parser
------------

A parser. This class cannot itself be instantiated; you can only use one of
its subclasses. Most classes in this module are Parser subclasses.

The method you'll typically use on Parser objects is parse_string.

.. class:: Parser

   x.__init__(...) initializes x; see help(type(x)) for signature

   .. method:: consume(self, text, position, end)



   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-------------
Class Present
-------------

A lookahead parser; it matches as long as the parser it's constructed with
matches at the specified position, but it doesn't actually consume any
input, and its result is None. If you need access to the result, you'll
probably want to use Preserve instead.

.. class:: Present(self, parser)



   .. method:: consume(self, text, position, end)



   .. method:: do_graph(self, graph)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

--------------
Class Preserve
--------------

A lookahead parser; it matches as long as the parser it's constructed with
matches at the specified position, but it doesn't actually consume any
input. Unlike Present, however, Preserve returns whatever its underlying
parser returned, even though it doesn't consume any input.

.. class:: Preserve(self, parser)



   .. method:: consume(self, text, position, end)



   .. method:: do_graph(self, graph)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-----------
Class Regex
-----------

A parser that matches the specified regular expression. Its result depends
on the groups_only parameter passed to the constructor: if groups_only is
None (the default), the result is the string that the regex matches. If
groups_only is True, a list of the values that the groups in the regex
matched is true; for example, Regex("(..)(.)(....)", groups_only=True)
would parse the string "abcdefg" into ["ab", "c", "defg"]. If groups_only
is False, the string that the regex matched is provided as the first item
in the list, and the groups are provided as the rest of the items in the
list; the above example with groups_only=False would parse the string
"abcdefg" into ["abcdefg", "ab", "c", "defg"].

>>> Regex("(..)(.)(....)", groups_only=True).parse_string("abcdefg")
['ab', 'c', 'defg']

If you can avoid using Regex without requiring exorbitant amounts of
additional code, it's generally best to, since error messages given by
combinations of Parcon parsers are generally more informative than an
error message providing a regex. If you really need to use Regex but you
still want informative error messages, you could wrap your Regex instance
in an instance of Expected.

The specified regex can be either a string representing the regular
expression or a pattern compiled with Python's re.compile. If you want to
specify flags to the regex, you'll need to compile it with re.compile, then
pass the result into Regex.

Unlike the behavior of normal Python regex groups, groups that did not
participate in a match are represented in the returned list (if
groups_only is not None) by the empty string instead of None. If enough
people want the ability for None to be used instead (and my email address
is in the docstring for this module, at the top, so send me an email if
you're one of the people that want this), I'll add a parameter that can be
passed to Regex to switch this back to the usual behavior of using None.

.. class:: Regex(self, regex, groups_only=None)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

------------
Class Repeat
------------

A parser that matches its underlying parser a certain number of times. If
the underlying parser did not match at least min times, this parser fails.
This parser stops parsing after max times, even if the underlying parser
would still match. The results of all of the parses are returned as a list.

If max is None, no maximum limit will be enforced. The same goes for min.

Repeat(parser, 0, None) is the same as ZeroOrMore(parser), and
Repeat(parser, 1, None) is the same as OneOrMore(parser).

.. class:: Repeat(self, parser, min, max)



   .. method:: consume(self, text, position, end)



   .. method:: do_graph(self, graph)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

------------
Class Result
------------

A result from a parser. Parcon users usually won't have any use for
instances of this class since it's primarily used internally by Parcon, but
if you're implementing your own Parser subclass, then you'll likely find
this class useful since you'll be returning instances of it.

You typically don't create instances of Result directly; instead, you
usually call either match() or failure(), which return result objects
indicating success or failure, respectively.

Three fields are made available on a Result object:

    expected: A list of expectations in the same format as provided to the
    failure() function
    
    end: The position at which the parser finished parsing, if this result
    indicates success. The value is undefined in the case of a failure.
    
    value: The value that the parser produced, if this result indicates
    success. The value is undefined in the case of a failure.

You can test whether or not a result indicates success by using it as a
boolean. For example:

>>> successful_result = match(0, "some random value", [])
>>> failed_result = failure([(0, EUnsatisfiable())])
>>> if successful_result:
...     print "Yes"
... else:
...     print "No"
...
Yes
>>> if failed_result:
...     print "Yes"
... else:
...     print "No"
...
No

.. class:: Result(self, end, value, expected)



------------
Class Return
------------

A parser that always succeeds, consumes no input, and always returns a
value specified when the Return instance is constructed.

Those of you familiar with functional programming will notice that this
parser implements a monadic return, hence its name.

.. class:: Return(self, value)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, whitespace)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

------------------------
Class SignificantLiteral
------------------------

A parser that matches the specified literal piece of text. Is succeeds
only if that piece of text is found. Unlike Literal, however,
SignificantLiteral returns the literal string passed into it instead of
None.

.. class:: SignificantLiteral(self, text)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

---------
Class Tag
---------

A parser that "tags", so to speak, the value returned from its underlying
parser. Specifically, you construct a Tag instance by specifying a tag and
a parser, and the specified parser's return value will be wrapped in a
Pair(tag, return_value). For example,

>>> Tag("test", AnyChar()).parse_string("a")
Pair(key='test', value='a')

The reason why this is useful is that named tuples are treated as objects
by Parcon things like Then and the flatten function, so they will be passed
around as objects, but they are treated as tuples by Python's dict
function. This allows you to use various parsers that assemble values
passed through Tag, and then add [flatten][dict] onto the end of that whole
parser group; the result of that parser will be a dictionary containing all
of the tagged values, with the tags as keys. For example, a parser that
parses numbers such as "123.45" into a dict of the form {"integer": "123",
"decimal": "45"} could be written as:

>>> decimal_parser = (Tag("integer", (+Digit())[concat]) + Tag("decimal",                              Optional("." + (+Digit())[concat], "")))[dict]

Of course, using the short notation parser["tag"] in place of Tag("tag",
parser), we can reduce that further to:

>>> decimal_parser = ((+Digit())[concat]["integer"] + Optional("." +                              (+Digit())[concat], "")["decimal"])[dict]

Note that the short notation of parser[tag] only works if tag is a string
(or a unicode instance; anything that subclasses from basestring works).
No other datatypes will work; if you want to use those, you'll need to use
Tag itself instead of the short notation.

If you want to preserve all values with a particular tag instead of just
one of them, you may want to use parser[list_dict] instead of parser[dict].
See the documentation for list_dict for more on what it does.

.. class:: Tag(self, tag, parser)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

----------
Class Then
----------

A parser that matches the first specified parser followed by the second.
If neither of them matches, or if only one of them matches, this parser
fails. If both of them match, the result is as follows, assuming A and B
are the results of the first and the second parser, respectively:

If A is None, the result is B.
If B is None, the result is A.
If A and B are tuples, the result is A + B.
If A is a tuple but B is not, the result is A + (B,).
If B is a tuple but A is not, the result is (A,) + B.
Otherwise, the result is (A, B).

Named tuples (instances of classes created with collections.namedtuple) are
not treated as tuples in the above decision process. In fact, any subclass
of tuple is treated as if it were a completely separate object and not a
tuple at all.

.. class:: Then(self, first, second)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

---------------
Class Translate
---------------

A parser that passes the result of the parser it's created with, if said
parser matches successfully, through a function, and the function's return
value is then used as the result. The function is not called if the
specified parser fails.

For example, the following parser would use the flatten function provided
by parcon to flatten any lists and tuples produced by the parser
example_parser:

Translate(example_parser, flatten)

The following parser would likewise expect another_parser to produce a list
of strings and concatenate them together into a single result string:

Translate(another_parser, "".join)

.. class:: Translate(self, parser, function)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

-----------
Class Upper
-----------

Same as CharIn(upper_chars).

.. class:: Upper(self)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

----------------
Class Whitespace
----------------

Same as CharIn(whitespace).

.. class:: Whitespace(self)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

----------
Class Word
----------

A parser that parses a word consisting of a certain set of allowed
characters. A minimum and maximum word length can also be specified, as can
a set of characters of which the first character in the word must be a
member.

If min is unspecified, it defaults to 1. Max defaults to None, which places
no upper limit on the number of characters that can be in this word.

Word parses as many characters as it can that are in the specified
character set until it's parsed the specified maximum number of characters,
or it hits a character not in the specified character set. If, at that
point, the number of characters parsed is less than min, this parser fails.
Otherwise, it succeeds and produces a string containing all the characters.

min can be zero, which will allow this parser to succeed even if there are
no characters available or if the first character is not in init_chars.
The empty string will be returned in such a case.

.. class:: Word(self, chars, init_chars=None, min=1, max=None)



   .. method:: consume(self, text, position, end)



   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

----------------
Class ZeroOrMore
----------------

A parser that matches the specified parser as many times as it can. The
results are collected into a list, which is then returned. Since
ZeroOrMore succeeds even if zero matches were made (the empty list will
be returned in such a case), this parser always succeeds.

.. class:: ZeroOrMore(self, parser)



   .. method:: consume(self, text, position, end)



   .. method:: create_railroad(self, options)



   .. method:: do_graph(self, graph)



   .. method:: draw_productions_to_image(self, img_type, options, filename, tail)



   .. method:: draw_productions_to_png(self, options, filename, tail=[])



   .. method:: draw_productions_to_svg(self, options, filename, tail=[])



   .. method:: draw_railroad_to_png(self, options, filename)

      Draws a syntax diagram for this object to the specified .png image file
      using the specified options. For now, just pass {} (i.e. an empty
      dictionary) as options; I'll document what this actually does at a
      later date.

   .. method:: get_productions(self)



   .. method:: graph(self)

      Graphs this Graphable object by calling its do_graph and the do_graph
      functions defined by all of the things that this Graphable depends on.
      The result will be a Graph object.

      Each node in the resulting Graph will be named after its respective
      object's identity, a.k.a. the value returned by the built-in id
      function.

      The quickest way to use this would be to do something like this:

      something.graph().draw("example.png")

      For the draw method to work, however, you must have the dot program
      (which is part of Graphviz) installed.

   .. method:: parse(self, text, position, end, space)



   .. method:: parse_string(self, string, all=True, whitespace=None)

      Parses a string using this parser and returns the result, or throws an
      exception if the parser does not match. If all is True (the default),
      an exception will be thrown if this parser does not match all of the
      input. Otherwise, if the parser only matches a portion of the input
      starting at the beginning, just that portion will be returned.

      whitespace is the whitespace parser to use; this parser will be applied
      (and its results discarded) between matching every other parser while
      attempting to parse the specified string. A typical grammar might have
      this parser represent whitespace and comments. An instance of Exact can
      be used to suppress whitespace parsing for a portion of the grammar,
      which you would most likely use in, for example, string literals. The
      default value for this parameter is Whitespace().

---------
Functions
---------



.. function:: concat(value, delimiter='')

   Walks through value, which should be a list or a tuple potentially
   containing other lists/tuples, and extracts all strings from it (and
   recursively from any other lists/tuples that it contains). These strings
   are then concatenated using the specified delimiter.

   Right now, this delegates to flatten to flatten out the specified value. It
   then iterates over all of the items in the resulting list and concatenates
   all of them that are strings.

.. function:: failure(expected)

   Returns a Result representing a failure of a parser to match. expected is
   a list of expectations that would have had to be satisfied in the text
   passed to the parser calling this method in order for it to potentially
   succeed. Expectations are 2-tuples of the position at which some particular
   piece of text was expected and an instance of one of the subclasses of
   Expectation describing what was expected.

.. function:: filter_expectations(expected)

   Extracts the expectations from the specified expectation list, which should
   be of the same format as that passed to failure(), that have the maximum
   position within the list. A tuple (position, expectations) will then be
   returned, where position is the maximum position and expectations is the
   list of expectations at that position.

   If the specified list is empty, (0, []) will be returned.

   All instances of EUnsatisfiable will be filtered from the expectation list,
   unless it consists only of EUnsatisfiable instances. In that case, only a
   single EUnsatisfiable will be present in the returned expectation list,
   even if there were more than one at the maximum position.

.. function:: flatten(value)

   A function that recursively flattens the specified value. Tuples and lists
   are flattened into the items that they contain. The result is a list.

   If a single non-list, non-tuple value is passed in, the result is a list
   containing just that item. If, however, that value is None, the result is
   the empty list.

   This function is intended to be used as the function passed to Translate
   where the parser passed to Translate could produce multiple nested lists of
   tuples and lists, and a single, flat, list is desired.

   Named tuples (instances of classes created with collections.namedtuple) are
   treated as normal object, not tuples, so they will not be flattened.

.. function:: format_expectations(position, expectations)

   Formats a position and a list of strings into a failure message that
   typically looks like this:

   At position n: expected one of x, y, z

   Position is the position to use for n. Expectations is the list of strings
   to use for x, y, and z.

   Note that if there is only one expectation, the message will instead look
   like:

   At position n: expected x

.. function:: format_failure(expected)

   Formats a list of expectations into a failure message that typically looks
   something like this:

   At position n: expected one of x, y, z

   Expectations are provided in the same format as passed to the failure()
   function.

   This function used to contain all of the formatting logic, but the logic
   has since been split into the functions filter_expectations,
   stringify_expectations, and format_expectations. This function now
   functions as a convenience wrapper around those three functions.

.. function:: list_dict(list_of_pairs)

   Similar to dict(list_of_pairs), but the values in the returned dict are
   lists containing one item for each pair with the specified key. In other
   words, this can be used to convert a list of 2-tuples into a dict where the
   same key might be present twice (or more) in the specified list; the value
   list in the resulting dict will have two (or more) items in it.

   This is intended to be used as parser[list_dict] in place of parser[dict]
   when all of the items with a particular tag need to be preserved; this is
   Parcon's equivalent to Pyparsing's setResultsName(..., listAllMatches=True)
   behavior.

   For example:

   >>> # The last tuple wins:
   >>> dict([(1,"one"),(2,"two"),(1,"first")])
   {1: 'first', 2: 'two'}
   >>> # All results included in lists:
   >>> list_dict([(1,"one"),(2,"two"),(1,"first")])
   {1: ['one', 'first'], 2: ['two']}

.. function:: match(end, value, expected)

   Returns a Result representing a parser successfully matching. end is the
   position in the string just after where the parser finished, or rather,
   where the next parser after this one would be expected to start parsing.
   value is the value that this parser resulted in, which is typically
   specific to the parser calling this function. expected is a list of
   expectations that would have allowed this parser to match more input than
   it did; this parameter takes the same format as its corresponding parameter
   to the failure function.

.. function:: op_add(first, second)



.. function:: op_and(first, second)



.. function:: op_call(parser, *args, **kwargs)



.. function:: op_getitem(parser, function)



.. function:: op_invert(parser)



.. function:: op_neg(parser)



.. function:: op_or(first, second)



.. function:: op_pos(parser)



.. function:: op_sub(first, second)



.. function:: parse_space(text, position, end, space)

   Repeatedly applies the specified whitespace parser to the specified text
   starting at the specified position until it no longer matches. The result
   of all of these parses will be discarded, and the location at which the
   whitespace parser failed will be returned.

.. function:: promote(value)

   Converts a value of some type to an appropriate parser. Right now, this
   returns the value as is if it's an instance of Parser, or Literal(value) if
   the value is a string.

.. function:: separated(item_parser, separator_parser)

   Creates and returns a parser that will parse one or more items parsed by
   item_parser, separated by separator_parser. The result of the parser is a
   list of the items produced by item_parser.

   Both item_parser and separator_parser will be automatically promote()d, so
   a string such as ",", for example, could be used as separator_parser
   without having to wrap it in a Literal first.

.. function:: stringify_expectations(expectations)

   Converts the specified list of Expectation objects into a list of strings.
   This essentially just returns [e.format() for e in expectations].